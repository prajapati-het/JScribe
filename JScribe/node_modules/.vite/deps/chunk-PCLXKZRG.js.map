{
  "version": 3,
  "sources": ["../../@lezer/markdown/dist/index.js", "../../@codemirror/lang-markdown/dist/index.js"],
  "sourcesContent": ["import { NodeType, NodeProp, NodeSet, Tree, Parser, parseMixed } from '@lezer/common';\r\nimport { styleTags, tags, Tag } from '@lezer/highlight';\r\n\r\nclass CompositeBlock {\r\n    static create(type, value, from, parentHash, end) {\r\n        let hash = (parentHash + (parentHash << 8) + type + (value << 4)) | 0;\r\n        return new CompositeBlock(type, value, from, hash, end, [], []);\r\n    }\r\n    constructor(type, \r\n    // Used for indentation in list items, markup character in lists\r\n    value, from, hash, end, children, positions) {\r\n        this.type = type;\r\n        this.value = value;\r\n        this.from = from;\r\n        this.hash = hash;\r\n        this.end = end;\r\n        this.children = children;\r\n        this.positions = positions;\r\n        this.hashProp = [[NodeProp.contextHash, hash]];\r\n    }\r\n    addChild(child, pos) {\r\n        if (child.prop(NodeProp.contextHash) != this.hash)\r\n            child = new Tree(child.type, child.children, child.positions, child.length, this.hashProp);\r\n        this.children.push(child);\r\n        this.positions.push(pos);\r\n    }\r\n    toTree(nodeSet, end = this.end) {\r\n        let last = this.children.length - 1;\r\n        if (last >= 0)\r\n            end = Math.max(end, this.positions[last] + this.children[last].length + this.from);\r\n        return new Tree(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({\r\n            makeTree: (children, positions, length) => new Tree(NodeType.none, children, positions, length, this.hashProp)\r\n        });\r\n    }\r\n}\r\nvar Type;\r\n(function (Type) {\r\n    Type[Type[\"Document\"] = 1] = \"Document\";\r\n    Type[Type[\"CodeBlock\"] = 2] = \"CodeBlock\";\r\n    Type[Type[\"FencedCode\"] = 3] = \"FencedCode\";\r\n    Type[Type[\"Blockquote\"] = 4] = \"Blockquote\";\r\n    Type[Type[\"HorizontalRule\"] = 5] = \"HorizontalRule\";\r\n    Type[Type[\"BulletList\"] = 6] = \"BulletList\";\r\n    Type[Type[\"OrderedList\"] = 7] = \"OrderedList\";\r\n    Type[Type[\"ListItem\"] = 8] = \"ListItem\";\r\n    Type[Type[\"ATXHeading1\"] = 9] = \"ATXHeading1\";\r\n    Type[Type[\"ATXHeading2\"] = 10] = \"ATXHeading2\";\r\n    Type[Type[\"ATXHeading3\"] = 11] = \"ATXHeading3\";\r\n    Type[Type[\"ATXHeading4\"] = 12] = \"ATXHeading4\";\r\n    Type[Type[\"ATXHeading5\"] = 13] = \"ATXHeading5\";\r\n    Type[Type[\"ATXHeading6\"] = 14] = \"ATXHeading6\";\r\n    Type[Type[\"SetextHeading1\"] = 15] = \"SetextHeading1\";\r\n    Type[Type[\"SetextHeading2\"] = 16] = \"SetextHeading2\";\r\n    Type[Type[\"HTMLBlock\"] = 17] = \"HTMLBlock\";\r\n    Type[Type[\"LinkReference\"] = 18] = \"LinkReference\";\r\n    Type[Type[\"Paragraph\"] = 19] = \"Paragraph\";\r\n    Type[Type[\"CommentBlock\"] = 20] = \"CommentBlock\";\r\n    Type[Type[\"ProcessingInstructionBlock\"] = 21] = \"ProcessingInstructionBlock\";\r\n    // Inline\r\n    Type[Type[\"Escape\"] = 22] = \"Escape\";\r\n    Type[Type[\"Entity\"] = 23] = \"Entity\";\r\n    Type[Type[\"HardBreak\"] = 24] = \"HardBreak\";\r\n    Type[Type[\"Emphasis\"] = 25] = \"Emphasis\";\r\n    Type[Type[\"StrongEmphasis\"] = 26] = \"StrongEmphasis\";\r\n    Type[Type[\"Link\"] = 27] = \"Link\";\r\n    Type[Type[\"Image\"] = 28] = \"Image\";\r\n    Type[Type[\"InlineCode\"] = 29] = \"InlineCode\";\r\n    Type[Type[\"HTMLTag\"] = 30] = \"HTMLTag\";\r\n    Type[Type[\"Comment\"] = 31] = \"Comment\";\r\n    Type[Type[\"ProcessingInstruction\"] = 32] = \"ProcessingInstruction\";\r\n    Type[Type[\"Autolink\"] = 33] = \"Autolink\";\r\n    // Smaller tokens\r\n    Type[Type[\"HeaderMark\"] = 34] = \"HeaderMark\";\r\n    Type[Type[\"QuoteMark\"] = 35] = \"QuoteMark\";\r\n    Type[Type[\"ListMark\"] = 36] = \"ListMark\";\r\n    Type[Type[\"LinkMark\"] = 37] = \"LinkMark\";\r\n    Type[Type[\"EmphasisMark\"] = 38] = \"EmphasisMark\";\r\n    Type[Type[\"CodeMark\"] = 39] = \"CodeMark\";\r\n    Type[Type[\"CodeText\"] = 40] = \"CodeText\";\r\n    Type[Type[\"CodeInfo\"] = 41] = \"CodeInfo\";\r\n    Type[Type[\"LinkTitle\"] = 42] = \"LinkTitle\";\r\n    Type[Type[\"LinkLabel\"] = 43] = \"LinkLabel\";\r\n    Type[Type[\"URL\"] = 44] = \"URL\";\r\n})(Type || (Type = {}));\r\n/// Data structure used to accumulate a block's content during [leaf\r\n/// block parsing](#BlockParser.leaf).\r\nclass LeafBlock {\r\n    /// @internal\r\n    constructor(\r\n    /// The start position of the block.\r\n    start, \r\n    /// The block's text content.\r\n    content) {\r\n        this.start = start;\r\n        this.content = content;\r\n        /// @internal\r\n        this.marks = [];\r\n        /// The block parsers active for this block.\r\n        this.parsers = [];\r\n    }\r\n}\r\n/// Data structure used during block-level per-line parsing.\r\nclass Line {\r\n    constructor() {\r\n        /// The line's full text.\r\n        this.text = \"\";\r\n        /// The base indent provided by the composite contexts (that have\r\n        /// been handled so far).\r\n        this.baseIndent = 0;\r\n        /// The string position corresponding to the base indent.\r\n        this.basePos = 0;\r\n        /// The number of contexts handled @internal\r\n        this.depth = 0;\r\n        /// Any markers (i.e. block quote markers) parsed for the contexts. @internal\r\n        this.markers = [];\r\n        /// The position of the next non-whitespace character beyond any\r\n        /// list, blockquote, or other composite block markers.\r\n        this.pos = 0;\r\n        /// The column of the next non-whitespace character.\r\n        this.indent = 0;\r\n        /// The character code of the character after `pos`.\r\n        this.next = -1;\r\n    }\r\n    /// @internal\r\n    forward() {\r\n        if (this.basePos > this.pos)\r\n            this.forwardInner();\r\n    }\r\n    /// @internal\r\n    forwardInner() {\r\n        let newPos = this.skipSpace(this.basePos);\r\n        this.indent = this.countIndent(newPos, this.pos, this.indent);\r\n        this.pos = newPos;\r\n        this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);\r\n    }\r\n    /// Skip whitespace after the given position, return the position of\r\n    /// the next non-space character or the end of the line if there's\r\n    /// only space after `from`.\r\n    skipSpace(from) { return skipSpace(this.text, from); }\r\n    /// @internal\r\n    reset(text) {\r\n        this.text = text;\r\n        this.baseIndent = this.basePos = this.pos = this.indent = 0;\r\n        this.forwardInner();\r\n        this.depth = 1;\r\n        while (this.markers.length)\r\n            this.markers.pop();\r\n    }\r\n    /// Move the line's base position forward to the given position.\r\n    /// This should only be called by composite [block\r\n    /// parsers](#BlockParser.parse) or [markup skipping\r\n    /// functions](#NodeSpec.composite).\r\n    moveBase(to) {\r\n        this.basePos = to;\r\n        this.baseIndent = this.countIndent(to, this.pos, this.indent);\r\n    }\r\n    /// Move the line's base position forward to the given _column_.\r\n    moveBaseColumn(indent) {\r\n        this.baseIndent = indent;\r\n        this.basePos = this.findColumn(indent);\r\n    }\r\n    /// Store a composite-block-level marker. Should be called from\r\n    /// [markup skipping functions](#NodeSpec.composite) when they\r\n    /// consume any non-whitespace characters.\r\n    addMarker(elt) {\r\n        this.markers.push(elt);\r\n    }\r\n    /// Find the column position at `to`, optionally starting at a given\r\n    /// position and column.\r\n    countIndent(to, from = 0, indent = 0) {\r\n        for (let i = from; i < to; i++)\r\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\r\n        return indent;\r\n    }\r\n    /// Find the position corresponding to the given column.\r\n    findColumn(goal) {\r\n        let i = 0;\r\n        for (let indent = 0; i < this.text.length && indent < goal; i++)\r\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\r\n        return i;\r\n    }\r\n    /// @internal\r\n    scrub() {\r\n        if (!this.baseIndent)\r\n            return this.text;\r\n        let result = \"\";\r\n        for (let i = 0; i < this.basePos; i++)\r\n            result += \" \";\r\n        return result + this.text.slice(this.basePos);\r\n    }\r\n}\r\nfunction skipForList(bl, cx, line) {\r\n    if (line.pos == line.text.length ||\r\n        (bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent))\r\n        return true;\r\n    if (line.indent >= line.baseIndent + 4)\r\n        return false;\r\n    let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);\r\n    return size > 0 &&\r\n        (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) &&\r\n        line.text.charCodeAt(line.pos + size - 1) == bl.value;\r\n}\r\nconst DefaultSkipMarkup = {\r\n    [Type.Blockquote](bl, cx, line) {\r\n        if (line.next != 62 /* '>' */)\r\n            return false;\r\n        line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));\r\n        line.moveBase(line.pos + (space(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));\r\n        bl.end = cx.lineStart + line.text.length;\r\n        return true;\r\n    },\r\n    [Type.ListItem](bl, _cx, line) {\r\n        if (line.indent < line.baseIndent + bl.value && line.next > -1)\r\n            return false;\r\n        line.moveBaseColumn(line.baseIndent + bl.value);\r\n        return true;\r\n    },\r\n    [Type.OrderedList]: skipForList,\r\n    [Type.BulletList]: skipForList,\r\n    [Type.Document]() { return true; }\r\n};\r\nfunction space(ch) { return ch == 32 || ch == 9 || ch == 10 || ch == 13; }\r\nfunction skipSpace(line, i = 0) {\r\n    while (i < line.length && space(line.charCodeAt(i)))\r\n        i++;\r\n    return i;\r\n}\r\nfunction skipSpaceBack(line, i, to) {\r\n    while (i > to && space(line.charCodeAt(i - 1)))\r\n        i--;\r\n    return i;\r\n}\r\nfunction isFencedCode(line) {\r\n    if (line.next != 96 && line.next != 126 /* '`~' */)\r\n        return -1;\r\n    let pos = line.pos + 1;\r\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\r\n        pos++;\r\n    if (pos < line.pos + 3)\r\n        return -1;\r\n    if (line.next == 96)\r\n        for (let i = pos; i < line.text.length; i++)\r\n            if (line.text.charCodeAt(i) == 96)\r\n                return -1;\r\n    return pos;\r\n}\r\nfunction isBlockquote(line) {\r\n    return line.next != 62 /* '>' */ ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;\r\n}\r\nfunction isHorizontalRule(line, cx, breaking) {\r\n    if (line.next != 42 && line.next != 45 && line.next != 95 /* '_-*' */)\r\n        return -1;\r\n    let count = 1;\r\n    for (let pos = line.pos + 1; pos < line.text.length; pos++) {\r\n        let ch = line.text.charCodeAt(pos);\r\n        if (ch == line.next)\r\n            count++;\r\n        else if (!space(ch))\r\n            return -1;\r\n    }\r\n    // Setext headers take precedence\r\n    if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length)\r\n        return -1;\r\n    return count < 3 ? -1 : 1;\r\n}\r\nfunction inList(cx, type) {\r\n    for (let i = cx.stack.length - 1; i >= 0; i--)\r\n        if (cx.stack[i].type == type)\r\n            return true;\r\n    return false;\r\n}\r\nfunction isBulletList(line, cx, breaking) {\r\n    return (line.next == 45 || line.next == 43 || line.next == 42 /* '-+*' */) &&\r\n        (line.pos == line.text.length - 1 || space(line.text.charCodeAt(line.pos + 1))) &&\r\n        (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;\r\n}\r\nfunction isOrderedList(line, cx, breaking) {\r\n    let pos = line.pos, next = line.next;\r\n    for (;;) {\r\n        if (next >= 48 && next <= 57 /* '0-9' */)\r\n            pos++;\r\n        else\r\n            break;\r\n        if (pos == line.text.length)\r\n            return -1;\r\n        next = line.text.charCodeAt(pos);\r\n    }\r\n    if (pos == line.pos || pos > line.pos + 9 ||\r\n        (next != 46 && next != 41 /* '.)' */) ||\r\n        (pos < line.text.length - 1 && !space(line.text.charCodeAt(pos + 1))) ||\r\n        breaking && !inList(cx, Type.OrderedList) &&\r\n            (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49 /* '1' */))\r\n        return -1;\r\n    return pos + 1 - line.pos;\r\n}\r\nfunction isAtxHeading(line) {\r\n    if (line.next != 35 /* '#' */)\r\n        return -1;\r\n    let pos = line.pos + 1;\r\n    while (pos < line.text.length && line.text.charCodeAt(pos) == 35)\r\n        pos++;\r\n    if (pos < line.text.length && line.text.charCodeAt(pos) != 32)\r\n        return -1;\r\n    let size = pos - line.pos;\r\n    return size > 6 ? -1 : size;\r\n}\r\nfunction isSetextUnderline(line) {\r\n    if (line.next != 45 && line.next != 61 /* '-=' */ || line.indent >= line.baseIndent + 4)\r\n        return -1;\r\n    let pos = line.pos + 1;\r\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\r\n        pos++;\r\n    let end = pos;\r\n    while (pos < line.text.length && space(line.text.charCodeAt(pos)))\r\n        pos++;\r\n    return pos == line.text.length ? end : -1;\r\n}\r\nconst EmptyLine = /^[ \\t]*$/, CommentEnd = /-->/, ProcessingEnd = /\\?>/;\r\nconst HTMLBlockStyle = [\r\n    [/^<(?:script|pre|style)(?:\\s|>|$)/i, /<\\/(?:script|pre|style)>/i],\r\n    [/^\\s*<!--/, CommentEnd],\r\n    [/^\\s*<\\?/, ProcessingEnd],\r\n    [/^\\s*<![A-Z]/, />/],\r\n    [/^\\s*<!\\[CDATA\\[/, /\\]\\]>/],\r\n    [/^\\s*<\\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\\s|\\/?>|$)/i, EmptyLine],\r\n    [/^\\s*(?:<\\/[a-z][\\w-]*\\s*>|<[a-z][\\w-]*(\\s+[a-z:_][\\w-.]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*>)\\s*$/i, EmptyLine]\r\n];\r\nfunction isHTMLBlock(line, _cx, breaking) {\r\n    if (line.next != 60 /* '<' */)\r\n        return -1;\r\n    let rest = line.text.slice(line.pos);\r\n    for (let i = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i < e; i++)\r\n        if (HTMLBlockStyle[i][0].test(rest))\r\n            return i;\r\n    return -1;\r\n}\r\nfunction getListIndent(line, pos) {\r\n    let indentAfter = line.countIndent(pos, line.pos, line.indent);\r\n    let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);\r\n    return indented >= indentAfter + 5 ? indentAfter + 1 : indented;\r\n}\r\nfunction addCodeText(marks, from, to) {\r\n    let last = marks.length - 1;\r\n    if (last >= 0 && marks[last].to == from && marks[last].type == Type.CodeText)\r\n        marks[last].to = to;\r\n    else\r\n        marks.push(elt(Type.CodeText, from, to));\r\n}\r\n// Rules for parsing blocks. A return value of false means the rule\r\n// doesn't apply here, true means it does. When true is returned and\r\n// `p.line` has been updated, the rule is assumed to have consumed a\r\n// leaf block. Otherwise, it is assumed to have opened a context.\r\nconst DefaultBlockParsers = {\r\n    LinkReference: undefined,\r\n    IndentedCode(cx, line) {\r\n        let base = line.baseIndent + 4;\r\n        if (line.indent < base)\r\n            return false;\r\n        let start = line.findColumn(base);\r\n        let from = cx.lineStart + start, to = cx.lineStart + line.text.length;\r\n        let marks = [], pendingMarks = [];\r\n        addCodeText(marks, from, to);\r\n        while (cx.nextLine() && line.depth >= cx.stack.length) {\r\n            if (line.pos == line.text.length) { // Empty\r\n                addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);\r\n                for (let m of line.markers)\r\n                    pendingMarks.push(m);\r\n            }\r\n            else if (line.indent < base) {\r\n                break;\r\n            }\r\n            else {\r\n                if (pendingMarks.length) {\r\n                    for (let m of pendingMarks) {\r\n                        if (m.type == Type.CodeText)\r\n                            addCodeText(marks, m.from, m.to);\r\n                        else\r\n                            marks.push(m);\r\n                    }\r\n                    pendingMarks = [];\r\n                }\r\n                addCodeText(marks, cx.lineStart - 1, cx.lineStart);\r\n                for (let m of line.markers)\r\n                    marks.push(m);\r\n                to = cx.lineStart + line.text.length;\r\n                let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);\r\n                if (codeStart < to)\r\n                    addCodeText(marks, codeStart, to);\r\n            }\r\n        }\r\n        if (pendingMarks.length) {\r\n            pendingMarks = pendingMarks.filter(m => m.type != Type.CodeText);\r\n            if (pendingMarks.length)\r\n                line.markers = pendingMarks.concat(line.markers);\r\n        }\r\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.CodeBlock, to - from), from);\r\n        return true;\r\n    },\r\n    FencedCode(cx, line) {\r\n        let fenceEnd = isFencedCode(line);\r\n        if (fenceEnd < 0)\r\n            return false;\r\n        let from = cx.lineStart + line.pos, ch = line.next, len = fenceEnd - line.pos;\r\n        let infoFrom = line.skipSpace(fenceEnd), infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);\r\n        let marks = [elt(Type.CodeMark, from, from + len)];\r\n        if (infoFrom < infoTo)\r\n            marks.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));\r\n        for (let first = true; cx.nextLine() && line.depth >= cx.stack.length; first = false) {\r\n            let i = line.pos;\r\n            if (line.indent - line.baseIndent < 4)\r\n                while (i < line.text.length && line.text.charCodeAt(i) == ch)\r\n                    i++;\r\n            if (i - line.pos >= len && line.skipSpace(i) == line.text.length) {\r\n                for (let m of line.markers)\r\n                    marks.push(m);\r\n                marks.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i));\r\n                cx.nextLine();\r\n                break;\r\n            }\r\n            else {\r\n                if (!first)\r\n                    addCodeText(marks, cx.lineStart - 1, cx.lineStart);\r\n                for (let m of line.markers)\r\n                    marks.push(m);\r\n                let textStart = cx.lineStart + line.basePos, textEnd = cx.lineStart + line.text.length;\r\n                if (textStart < textEnd)\r\n                    addCodeText(marks, textStart, textEnd);\r\n            }\r\n        }\r\n        cx.addNode(cx.buffer.writeElements(marks, -from)\r\n            .finish(Type.FencedCode, cx.prevLineEnd() - from), from);\r\n        return true;\r\n    },\r\n    Blockquote(cx, line) {\r\n        let size = isBlockquote(line);\r\n        if (size < 0)\r\n            return false;\r\n        cx.startContext(Type.Blockquote, line.pos);\r\n        cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);\r\n        line.moveBase(line.pos + size);\r\n        return null;\r\n    },\r\n    HorizontalRule(cx, line) {\r\n        if (isHorizontalRule(line, cx, false) < 0)\r\n            return false;\r\n        let from = cx.lineStart + line.pos;\r\n        cx.nextLine();\r\n        cx.addNode(Type.HorizontalRule, from);\r\n        return true;\r\n    },\r\n    BulletList(cx, line) {\r\n        let size = isBulletList(line, cx, false);\r\n        if (size < 0)\r\n            return false;\r\n        if (cx.block.type != Type.BulletList)\r\n            cx.startContext(Type.BulletList, line.basePos, line.next);\r\n        let newBase = getListIndent(line, line.pos + 1);\r\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\r\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\r\n        line.moveBaseColumn(newBase);\r\n        return null;\r\n    },\r\n    OrderedList(cx, line) {\r\n        let size = isOrderedList(line, cx, false);\r\n        if (size < 0)\r\n            return false;\r\n        if (cx.block.type != Type.OrderedList)\r\n            cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));\r\n        let newBase = getListIndent(line, line.pos + size);\r\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\r\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\r\n        line.moveBaseColumn(newBase);\r\n        return null;\r\n    },\r\n    ATXHeading(cx, line) {\r\n        let size = isAtxHeading(line);\r\n        if (size < 0)\r\n            return false;\r\n        let off = line.pos, from = cx.lineStart + off;\r\n        let endOfSpace = skipSpaceBack(line.text, line.text.length, off), after = endOfSpace;\r\n        while (after > off && line.text.charCodeAt(after - 1) == line.next)\r\n            after--;\r\n        if (after == endOfSpace || after == off || !space(line.text.charCodeAt(after - 1)))\r\n            after = line.text.length;\r\n        let buf = cx.buffer\r\n            .write(Type.HeaderMark, 0, size)\r\n            .writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1), -from);\r\n        if (after < line.text.length)\r\n            buf.write(Type.HeaderMark, after - off, endOfSpace - off);\r\n        let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);\r\n        cx.nextLine();\r\n        cx.addNode(node, from);\r\n        return true;\r\n    },\r\n    HTMLBlock(cx, line) {\r\n        let type = isHTMLBlock(line, cx, false);\r\n        if (type < 0)\r\n            return false;\r\n        let from = cx.lineStart + line.pos, end = HTMLBlockStyle[type][1];\r\n        let marks = [], trailing = end != EmptyLine;\r\n        while (!end.test(line.text) && cx.nextLine()) {\r\n            if (line.depth < cx.stack.length) {\r\n                trailing = false;\r\n                break;\r\n            }\r\n            for (let m of line.markers)\r\n                marks.push(m);\r\n        }\r\n        if (trailing)\r\n            cx.nextLine();\r\n        let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;\r\n        let to = cx.prevLineEnd();\r\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(nodeType, to - from), from);\r\n        return true;\r\n    },\r\n    SetextHeading: undefined // Specifies relative precedence for block-continue function\r\n};\r\n// This implements a state machine that incrementally parses link references. At each\r\n// next line, it looks ahead to see if the line continues the reference or not. If it\r\n// doesn't and a valid link is available ending before that line, it finishes that.\r\n// Similarly, on `finish` (when the leaf is terminated by external circumstances), it\r\n// creates a link reference if there's a valid reference up to the current point.\r\nclass LinkReferenceParser {\r\n    constructor(leaf) {\r\n        this.stage = 0 /* RefStage.Start */;\r\n        this.elts = [];\r\n        this.pos = 0;\r\n        this.start = leaf.start;\r\n        this.advance(leaf.content);\r\n    }\r\n    nextLine(cx, line, leaf) {\r\n        if (this.stage == -1 /* RefStage.Failed */)\r\n            return false;\r\n        let content = leaf.content + \"\\n\" + line.scrub();\r\n        let finish = this.advance(content);\r\n        if (finish > -1 && finish < content.length)\r\n            return this.complete(cx, leaf, finish);\r\n        return false;\r\n    }\r\n    finish(cx, leaf) {\r\n        if ((this.stage == 2 /* RefStage.Link */ || this.stage == 3 /* RefStage.Title */) && skipSpace(leaf.content, this.pos) == leaf.content.length)\r\n            return this.complete(cx, leaf, leaf.content.length);\r\n        return false;\r\n    }\r\n    complete(cx, leaf, len) {\r\n        cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));\r\n        return true;\r\n    }\r\n    nextStage(elt) {\r\n        if (elt) {\r\n            this.pos = elt.to - this.start;\r\n            this.elts.push(elt);\r\n            this.stage++;\r\n            return true;\r\n        }\r\n        if (elt === false)\r\n            this.stage = -1 /* RefStage.Failed */;\r\n        return false;\r\n    }\r\n    advance(content) {\r\n        for (;;) {\r\n            if (this.stage == -1 /* RefStage.Failed */) {\r\n                return -1;\r\n            }\r\n            else if (this.stage == 0 /* RefStage.Start */) {\r\n                if (!this.nextStage(parseLinkLabel(content, this.pos, this.start, true)))\r\n                    return -1;\r\n                if (content.charCodeAt(this.pos) != 58 /* ':' */)\r\n                    return this.stage = -1 /* RefStage.Failed */;\r\n                this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));\r\n                this.pos++;\r\n            }\r\n            else if (this.stage == 1 /* RefStage.Label */) {\r\n                if (!this.nextStage(parseURL(content, skipSpace(content, this.pos), this.start)))\r\n                    return -1;\r\n            }\r\n            else if (this.stage == 2 /* RefStage.Link */) {\r\n                let skip = skipSpace(content, this.pos), end = 0;\r\n                if (skip > this.pos) {\r\n                    let title = parseLinkTitle(content, skip, this.start);\r\n                    if (title) {\r\n                        let titleEnd = lineEnd(content, title.to - this.start);\r\n                        if (titleEnd > 0) {\r\n                            this.nextStage(title);\r\n                            end = titleEnd;\r\n                        }\r\n                    }\r\n                }\r\n                if (!end)\r\n                    end = lineEnd(content, this.pos);\r\n                return end > 0 && end < content.length ? end : -1;\r\n            }\r\n            else { // RefStage.Title\r\n                return lineEnd(content, this.pos);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction lineEnd(text, pos) {\r\n    for (; pos < text.length; pos++) {\r\n        let next = text.charCodeAt(pos);\r\n        if (next == 10)\r\n            break;\r\n        if (!space(next))\r\n            return -1;\r\n    }\r\n    return pos;\r\n}\r\nclass SetextHeadingParser {\r\n    nextLine(cx, line, leaf) {\r\n        let underline = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);\r\n        let next = line.next;\r\n        if (underline < 0)\r\n            return false;\r\n        let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline);\r\n        cx.nextLine();\r\n        cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [\r\n            ...cx.parser.parseInline(leaf.content, leaf.start),\r\n            underlineMark\r\n        ]));\r\n        return true;\r\n    }\r\n    finish() {\r\n        return false;\r\n    }\r\n}\r\nconst DefaultLeafBlocks = {\r\n    LinkReference(_, leaf) { return leaf.content.charCodeAt(0) == 91 /* '[' */ ? new LinkReferenceParser(leaf) : null; },\r\n    SetextHeading() { return new SetextHeadingParser; }\r\n};\r\nconst DefaultEndLeaf = [\r\n    (_, line) => isAtxHeading(line) >= 0,\r\n    (_, line) => isFencedCode(line) >= 0,\r\n    (_, line) => isBlockquote(line) >= 0,\r\n    (p, line) => isBulletList(line, p, true) >= 0,\r\n    (p, line) => isOrderedList(line, p, true) >= 0,\r\n    (p, line) => isHorizontalRule(line, p, true) >= 0,\r\n    (p, line) => isHTMLBlock(line, p, true) >= 0\r\n];\r\nconst scanLineResult = { text: \"\", end: 0 };\r\n/// Block-level parsing functions get access to this context object.\r\nclass BlockContext {\r\n    /// @internal\r\n    constructor(\r\n    /// The parser configuration used.\r\n    parser, \r\n    /// @internal\r\n    input, fragments, \r\n    /// @internal\r\n    ranges) {\r\n        this.parser = parser;\r\n        this.input = input;\r\n        this.ranges = ranges;\r\n        this.line = new Line();\r\n        this.atEnd = false;\r\n        /// For reused nodes on gaps, we can't directly put the original\r\n        /// node into the tree, since that may be bitter than its parent.\r\n        /// When this happens, we create a dummy tree that is replaced by\r\n        /// the proper node in `injectGaps` @internal\r\n        this.reusePlaceholders = new Map;\r\n        this.stoppedAt = null;\r\n        /// The range index that absoluteLineStart points into @internal\r\n        this.rangeI = 0;\r\n        this.to = ranges[ranges.length - 1].to;\r\n        this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;\r\n        this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);\r\n        this.stack = [this.block];\r\n        this.fragments = fragments.length ? new FragmentCursor(fragments, input) : null;\r\n        this.readLine();\r\n    }\r\n    get parsedPos() {\r\n        return this.absoluteLineStart;\r\n    }\r\n    advance() {\r\n        if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)\r\n            return this.finish();\r\n        let { line } = this;\r\n        for (;;) {\r\n            for (let markI = 0;;) {\r\n                let next = line.depth < this.stack.length ? this.stack[this.stack.length - 1] : null;\r\n                while (markI < line.markers.length && (!next || line.markers[markI].from < next.end)) {\r\n                    let mark = line.markers[markI++];\r\n                    this.addNode(mark.type, mark.from, mark.to);\r\n                }\r\n                if (!next)\r\n                    break;\r\n                this.finishContext();\r\n            }\r\n            if (line.pos < line.text.length)\r\n                break;\r\n            // Empty line\r\n            if (!this.nextLine())\r\n                return this.finish();\r\n        }\r\n        if (this.fragments && this.reuseFragment(line.basePos))\r\n            return null;\r\n        start: for (;;) {\r\n            for (let type of this.parser.blockParsers)\r\n                if (type) {\r\n                    let result = type(this, line);\r\n                    if (result != false) {\r\n                        if (result == true)\r\n                            return null;\r\n                        line.forward();\r\n                        continue start;\r\n                    }\r\n                }\r\n            break;\r\n        }\r\n        let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));\r\n        for (let parse of this.parser.leafBlockParsers)\r\n            if (parse) {\r\n                let parser = parse(this, leaf);\r\n                if (parser)\r\n                    leaf.parsers.push(parser);\r\n            }\r\n        lines: while (this.nextLine()) {\r\n            if (line.pos == line.text.length)\r\n                break;\r\n            if (line.indent < line.baseIndent + 4) {\r\n                for (let stop of this.parser.endLeafBlock)\r\n                    if (stop(this, line, leaf))\r\n                        break lines;\r\n            }\r\n            for (let parser of leaf.parsers)\r\n                if (parser.nextLine(this, line, leaf))\r\n                    return null;\r\n            leaf.content += \"\\n\" + line.scrub();\r\n            for (let m of line.markers)\r\n                leaf.marks.push(m);\r\n        }\r\n        this.finishLeaf(leaf);\r\n        return null;\r\n    }\r\n    stopAt(pos) {\r\n        if (this.stoppedAt != null && this.stoppedAt < pos)\r\n            throw new RangeError(\"Can't move stoppedAt forward\");\r\n        this.stoppedAt = pos;\r\n    }\r\n    reuseFragment(start) {\r\n        if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) ||\r\n            !this.fragments.matches(this.block.hash))\r\n            return false;\r\n        let taken = this.fragments.takeNodes(this);\r\n        if (!taken)\r\n            return false;\r\n        this.absoluteLineStart += taken;\r\n        this.lineStart = toRelative(this.absoluteLineStart, this.ranges);\r\n        this.moveRangeI();\r\n        if (this.absoluteLineStart < this.to) {\r\n            this.lineStart++;\r\n            this.absoluteLineStart++;\r\n            this.readLine();\r\n        }\r\n        else {\r\n            this.atEnd = true;\r\n            this.readLine();\r\n        }\r\n        return true;\r\n    }\r\n    /// The number of parent blocks surrounding the current block.\r\n    get depth() {\r\n        return this.stack.length;\r\n    }\r\n    /// Get the type of the parent block at the given depth. When no\r\n    /// depth is passed, return the type of the innermost parent.\r\n    parentType(depth = this.depth - 1) {\r\n        return this.parser.nodeSet.types[this.stack[depth].type];\r\n    }\r\n    /// Move to the next input line. This should only be called by\r\n    /// (non-composite) [block parsers](#BlockParser.parse) that consume\r\n    /// the line directly, or leaf block parser\r\n    /// [`nextLine`](#LeafBlockParser.nextLine) methods when they\r\n    /// consume the current line (and return true).\r\n    nextLine() {\r\n        this.lineStart += this.line.text.length;\r\n        if (this.absoluteLineEnd >= this.to) {\r\n            this.absoluteLineStart = this.absoluteLineEnd;\r\n            this.atEnd = true;\r\n            this.readLine();\r\n            return false;\r\n        }\r\n        else {\r\n            this.lineStart++;\r\n            this.absoluteLineStart = this.absoluteLineEnd + 1;\r\n            this.moveRangeI();\r\n            this.readLine();\r\n            return true;\r\n        }\r\n    }\r\n    moveRangeI() {\r\n        while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to) {\r\n            this.rangeI++;\r\n            this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);\r\n        }\r\n    }\r\n    /// @internal\r\n    scanLine(start) {\r\n        let r = scanLineResult;\r\n        r.end = start;\r\n        if (start >= this.to) {\r\n            r.text = \"\";\r\n        }\r\n        else {\r\n            r.text = this.lineChunkAt(start);\r\n            r.end += r.text.length;\r\n            if (this.ranges.length > 1) {\r\n                let textOffset = this.absoluteLineStart, rangeI = this.rangeI;\r\n                while (this.ranges[rangeI].to < r.end) {\r\n                    rangeI++;\r\n                    let nextFrom = this.ranges[rangeI].from;\r\n                    let after = this.lineChunkAt(nextFrom);\r\n                    r.end = nextFrom + after.length;\r\n                    r.text = r.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;\r\n                    textOffset = r.end - r.text.length;\r\n                }\r\n            }\r\n        }\r\n        return r;\r\n    }\r\n    /// @internal\r\n    readLine() {\r\n        let { line } = this, { text, end } = this.scanLine(this.absoluteLineStart);\r\n        this.absoluteLineEnd = end;\r\n        line.reset(text);\r\n        for (; line.depth < this.stack.length; line.depth++) {\r\n            let cx = this.stack[line.depth], handler = this.parser.skipContextMarkup[cx.type];\r\n            if (!handler)\r\n                throw new Error(\"Unhandled block context \" + Type[cx.type]);\r\n            if (!handler(cx, this, line))\r\n                break;\r\n            line.forward();\r\n        }\r\n    }\r\n    lineChunkAt(pos) {\r\n        let next = this.input.chunk(pos), text;\r\n        if (!this.input.lineChunks) {\r\n            let eol = next.indexOf(\"\\n\");\r\n            text = eol < 0 ? next : next.slice(0, eol);\r\n        }\r\n        else {\r\n            text = next == \"\\n\" ? \"\" : next;\r\n        }\r\n        return pos + text.length > this.to ? text.slice(0, this.to - pos) : text;\r\n    }\r\n    /// The end position of the previous line.\r\n    prevLineEnd() { return this.atEnd ? this.lineStart : this.lineStart - 1; }\r\n    /// @internal\r\n    startContext(type, start, value = 0) {\r\n        this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);\r\n        this.stack.push(this.block);\r\n    }\r\n    /// Start a composite block. Should only be called from [block\r\n    /// parser functions](#BlockParser.parse) that return null.\r\n    startComposite(type, start, value = 0) {\r\n        this.startContext(this.parser.getNodeType(type), start, value);\r\n    }\r\n    /// @internal\r\n    addNode(block, from, to) {\r\n        if (typeof block == \"number\")\r\n            block = new Tree(this.parser.nodeSet.types[block], none, none, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from);\r\n        this.block.addChild(block, from - this.block.from);\r\n    }\r\n    /// Add a block element. Can be called by [block\r\n    /// parsers](#BlockParser.parse).\r\n    addElement(elt) {\r\n        this.block.addChild(elt.toTree(this.parser.nodeSet), elt.from - this.block.from);\r\n    }\r\n    /// Add a block element from a [leaf parser](#LeafBlockParser). This\r\n    /// makes sure any extra composite block markup (such as blockquote\r\n    /// markers) inside the block are also added to the syntax tree.\r\n    addLeafElement(leaf, elt) {\r\n        this.addNode(this.buffer\r\n            .writeElements(injectMarks(elt.children, leaf.marks), -elt.from)\r\n            .finish(elt.type, elt.to - elt.from), elt.from);\r\n    }\r\n    /// @internal\r\n    finishContext() {\r\n        let cx = this.stack.pop();\r\n        let top = this.stack[this.stack.length - 1];\r\n        top.addChild(cx.toTree(this.parser.nodeSet), cx.from - top.from);\r\n        this.block = top;\r\n    }\r\n    finish() {\r\n        while (this.stack.length > 1)\r\n            this.finishContext();\r\n        return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));\r\n    }\r\n    addGaps(tree) {\r\n        return this.ranges.length > 1 ?\r\n            injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.reusePlaceholders) : tree;\r\n    }\r\n    /// @internal\r\n    finishLeaf(leaf) {\r\n        for (let parser of leaf.parsers)\r\n            if (parser.finish(this, leaf))\r\n                return;\r\n        let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);\r\n        this.addNode(this.buffer\r\n            .writeElements(inline, -leaf.start)\r\n            .finish(Type.Paragraph, leaf.content.length), leaf.start);\r\n    }\r\n    elt(type, from, to, children) {\r\n        if (typeof type == \"string\")\r\n            return elt(this.parser.getNodeType(type), from, to, children);\r\n        return new TreeElement(type, from);\r\n    }\r\n    /// @internal\r\n    get buffer() { return new Buffer(this.parser.nodeSet); }\r\n}\r\nfunction injectGaps(ranges, rangeI, tree, offset, dummies) {\r\n    let rangeEnd = ranges[rangeI].to;\r\n    let children = [], positions = [], start = tree.from + offset;\r\n    function movePastNext(upto, inclusive) {\r\n        while (inclusive ? upto >= rangeEnd : upto > rangeEnd) {\r\n            let size = ranges[rangeI + 1].from - rangeEnd;\r\n            offset += size;\r\n            upto += size;\r\n            rangeI++;\r\n            rangeEnd = ranges[rangeI].to;\r\n        }\r\n    }\r\n    for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {\r\n        movePastNext(ch.from + offset, true);\r\n        let from = ch.from + offset, node, reuse = dummies.get(ch.tree);\r\n        if (reuse) {\r\n            node = reuse;\r\n        }\r\n        else if (ch.to + offset > rangeEnd) {\r\n            node = injectGaps(ranges, rangeI, ch, offset, dummies);\r\n            movePastNext(ch.to + offset, false);\r\n        }\r\n        else {\r\n            node = ch.toTree();\r\n        }\r\n        children.push(node);\r\n        positions.push(from - start);\r\n    }\r\n    movePastNext(tree.to + offset, false);\r\n    return new Tree(tree.type, children, positions, tree.to + offset - start, tree.tree ? tree.tree.propValues : undefined);\r\n}\r\n/// A Markdown parser configuration.\r\nclass MarkdownParser extends Parser {\r\n    /// @internal\r\n    constructor(\r\n    /// The parser's syntax [node\r\n    /// types](https://lezer.codemirror.net/docs/ref/#common.NodeSet).\r\n    nodeSet, \r\n    /// @internal\r\n    blockParsers, \r\n    /// @internal\r\n    leafBlockParsers, \r\n    /// @internal\r\n    blockNames, \r\n    /// @internal\r\n    endLeafBlock, \r\n    /// @internal\r\n    skipContextMarkup, \r\n    /// @internal\r\n    inlineParsers, \r\n    /// @internal\r\n    inlineNames, \r\n    /// @internal\r\n    wrappers) {\r\n        super();\r\n        this.nodeSet = nodeSet;\r\n        this.blockParsers = blockParsers;\r\n        this.leafBlockParsers = leafBlockParsers;\r\n        this.blockNames = blockNames;\r\n        this.endLeafBlock = endLeafBlock;\r\n        this.skipContextMarkup = skipContextMarkup;\r\n        this.inlineParsers = inlineParsers;\r\n        this.inlineNames = inlineNames;\r\n        this.wrappers = wrappers;\r\n        /// @internal\r\n        this.nodeTypes = Object.create(null);\r\n        for (let t of nodeSet.types)\r\n            this.nodeTypes[t.name] = t.id;\r\n    }\r\n    createParse(input, fragments, ranges) {\r\n        let parse = new BlockContext(this, input, fragments, ranges);\r\n        for (let w of this.wrappers)\r\n            parse = w(parse, input, fragments, ranges);\r\n        return parse;\r\n    }\r\n    /// Reconfigure the parser.\r\n    configure(spec) {\r\n        let config = resolveConfig(spec);\r\n        if (!config)\r\n            return this;\r\n        let { nodeSet, skipContextMarkup } = this;\r\n        let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;\r\n        if (nonEmpty(config.defineNodes)) {\r\n            skipContextMarkup = Object.assign({}, skipContextMarkup);\r\n            let nodeTypes = nodeSet.types.slice(), styles;\r\n            for (let s of config.defineNodes) {\r\n                let { name, block, composite, style } = typeof s == \"string\" ? { name: s } : s;\r\n                if (nodeTypes.some(t => t.name == name))\r\n                    continue;\r\n                if (composite)\r\n                    skipContextMarkup[nodeTypes.length] =\r\n                        (bl, cx, line) => composite(cx, line, bl.value);\r\n                let id = nodeTypes.length;\r\n                let group = composite ? [\"Block\", \"BlockContext\"] : !block ? undefined\r\n                    : id >= Type.ATXHeading1 && id <= Type.SetextHeading2 ? [\"Block\", \"LeafBlock\", \"Heading\"] : [\"Block\", \"LeafBlock\"];\r\n                nodeTypes.push(NodeType.define({\r\n                    id,\r\n                    name,\r\n                    props: group && [[NodeProp.group, group]]\r\n                }));\r\n                if (style) {\r\n                    if (!styles)\r\n                        styles = {};\r\n                    if (Array.isArray(style) || style instanceof Tag)\r\n                        styles[name] = style;\r\n                    else\r\n                        Object.assign(styles, style);\r\n                }\r\n            }\r\n            nodeSet = new NodeSet(nodeTypes);\r\n            if (styles)\r\n                nodeSet = nodeSet.extend(styleTags(styles));\r\n        }\r\n        if (nonEmpty(config.props))\r\n            nodeSet = nodeSet.extend(...config.props);\r\n        if (nonEmpty(config.remove)) {\r\n            for (let rm of config.remove) {\r\n                let block = this.blockNames.indexOf(rm), inline = this.inlineNames.indexOf(rm);\r\n                if (block > -1)\r\n                    blockParsers[block] = leafBlockParsers[block] = undefined;\r\n                if (inline > -1)\r\n                    inlineParsers[inline] = undefined;\r\n            }\r\n        }\r\n        if (nonEmpty(config.parseBlock)) {\r\n            for (let spec of config.parseBlock) {\r\n                let found = blockNames.indexOf(spec.name);\r\n                if (found > -1) {\r\n                    blockParsers[found] = spec.parse;\r\n                    leafBlockParsers[found] = spec.leaf;\r\n                }\r\n                else {\r\n                    let pos = spec.before ? findName(blockNames, spec.before)\r\n                        : spec.after ? findName(blockNames, spec.after) + 1 : blockNames.length - 1;\r\n                    blockParsers.splice(pos, 0, spec.parse);\r\n                    leafBlockParsers.splice(pos, 0, spec.leaf);\r\n                    blockNames.splice(pos, 0, spec.name);\r\n                }\r\n                if (spec.endLeaf)\r\n                    endLeafBlock.push(spec.endLeaf);\r\n            }\r\n        }\r\n        if (nonEmpty(config.parseInline)) {\r\n            for (let spec of config.parseInline) {\r\n                let found = inlineNames.indexOf(spec.name);\r\n                if (found > -1) {\r\n                    inlineParsers[found] = spec.parse;\r\n                }\r\n                else {\r\n                    let pos = spec.before ? findName(inlineNames, spec.before)\r\n                        : spec.after ? findName(inlineNames, spec.after) + 1 : inlineNames.length - 1;\r\n                    inlineParsers.splice(pos, 0, spec.parse);\r\n                    inlineNames.splice(pos, 0, spec.name);\r\n                }\r\n            }\r\n        }\r\n        if (config.wrap)\r\n            wrappers = wrappers.concat(config.wrap);\r\n        return new MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);\r\n    }\r\n    /// @internal\r\n    getNodeType(name) {\r\n        let found = this.nodeTypes[name];\r\n        if (found == null)\r\n            throw new RangeError(`Unknown node type '${name}'`);\r\n        return found;\r\n    }\r\n    /// Parse the given piece of inline text at the given offset,\r\n    /// returning an array of [`Element`](#Element) objects representing\r\n    /// the inline content.\r\n    parseInline(text, offset) {\r\n        let cx = new InlineContext(this, text, offset);\r\n        outer: for (let pos = offset; pos < cx.end;) {\r\n            let next = cx.char(pos);\r\n            for (let token of this.inlineParsers)\r\n                if (token) {\r\n                    let result = token(cx, next, pos);\r\n                    if (result >= 0) {\r\n                        pos = result;\r\n                        continue outer;\r\n                    }\r\n                }\r\n            pos++;\r\n        }\r\n        return cx.resolveMarkers(0);\r\n    }\r\n}\r\nfunction nonEmpty(a) {\r\n    return a != null && a.length > 0;\r\n}\r\nfunction resolveConfig(spec) {\r\n    if (!Array.isArray(spec))\r\n        return spec;\r\n    if (spec.length == 0)\r\n        return null;\r\n    let conf = resolveConfig(spec[0]);\r\n    if (spec.length == 1)\r\n        return conf;\r\n    let rest = resolveConfig(spec.slice(1));\r\n    if (!rest || !conf)\r\n        return conf || rest;\r\n    let conc = (a, b) => (a || none).concat(b || none);\r\n    let wrapA = conf.wrap, wrapB = rest.wrap;\r\n    return {\r\n        props: conc(conf.props, rest.props),\r\n        defineNodes: conc(conf.defineNodes, rest.defineNodes),\r\n        parseBlock: conc(conf.parseBlock, rest.parseBlock),\r\n        parseInline: conc(conf.parseInline, rest.parseInline),\r\n        remove: conc(conf.remove, rest.remove),\r\n        wrap: !wrapA ? wrapB : !wrapB ? wrapA :\r\n            (inner, input, fragments, ranges) => wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)\r\n    };\r\n}\r\nfunction findName(names, name) {\r\n    let found = names.indexOf(name);\r\n    if (found < 0)\r\n        throw new RangeError(`Position specified relative to unknown parser ${name}`);\r\n    return found;\r\n}\r\nlet nodeTypes = [NodeType.none];\r\nfor (let i = 1, name; name = Type[i]; i++) {\r\n    nodeTypes[i] = NodeType.define({\r\n        id: i,\r\n        name,\r\n        props: i >= Type.Escape ? [] : [[NodeProp.group, i in DefaultSkipMarkup ? [\"Block\", \"BlockContext\"] : [\"Block\", \"LeafBlock\"]]],\r\n        top: name == \"Document\"\r\n    });\r\n}\r\nconst none = [];\r\nclass Buffer {\r\n    constructor(nodeSet) {\r\n        this.nodeSet = nodeSet;\r\n        this.content = [];\r\n        this.nodes = [];\r\n    }\r\n    write(type, from, to, children = 0) {\r\n        this.content.push(type, from, to, 4 + children * 4);\r\n        return this;\r\n    }\r\n    writeElements(elts, offset = 0) {\r\n        for (let e of elts)\r\n            e.writeTo(this, offset);\r\n        return this;\r\n    }\r\n    finish(type, length) {\r\n        return Tree.build({\r\n            buffer: this.content,\r\n            nodeSet: this.nodeSet,\r\n            reused: this.nodes,\r\n            topID: type,\r\n            length\r\n        });\r\n    }\r\n}\r\n/// Elements are used to compose syntax nodes during parsing.\r\nclass Element {\r\n    /// @internal\r\n    constructor(\r\n    /// The node's\r\n    /// [id](https://lezer.codemirror.net/docs/ref/#common.NodeType.id).\r\n    type, \r\n    /// The start of the node, as an offset from the start of the document.\r\n    from, \r\n    /// The end of the node.\r\n    to, \r\n    /// The node's child nodes @internal\r\n    children = none) {\r\n        this.type = type;\r\n        this.from = from;\r\n        this.to = to;\r\n        this.children = children;\r\n    }\r\n    /// @internal\r\n    writeTo(buf, offset) {\r\n        let startOff = buf.content.length;\r\n        buf.writeElements(this.children, offset);\r\n        buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);\r\n    }\r\n    /// @internal\r\n    toTree(nodeSet) {\r\n        return new Buffer(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);\r\n    }\r\n}\r\nclass TreeElement {\r\n    constructor(tree, from) {\r\n        this.tree = tree;\r\n        this.from = from;\r\n    }\r\n    get to() { return this.from + this.tree.length; }\r\n    get type() { return this.tree.type.id; }\r\n    get children() { return none; }\r\n    writeTo(buf, offset) {\r\n        buf.nodes.push(this.tree);\r\n        buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);\r\n    }\r\n    toTree() { return this.tree; }\r\n}\r\nfunction elt(type, from, to, children) {\r\n    return new Element(type, from, to, children);\r\n}\r\nconst EmphasisUnderscore = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\r\nconst EmphasisAsterisk = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\r\nconst LinkStart = {}, ImageStart = {};\r\nclass InlineDelimiter {\r\n    constructor(type, from, to, side) {\r\n        this.type = type;\r\n        this.from = from;\r\n        this.to = to;\r\n        this.side = side;\r\n    }\r\n}\r\nconst Escapable = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\r\nlet Punctuation = /[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~\\xA1\\u2010-\\u2027]/;\r\ntry {\r\n    Punctuation = new RegExp(\"[\\\\p{Pc}|\\\\p{Pd}|\\\\p{Pe}|\\\\p{Pf}|\\\\p{Pi}|\\\\p{Po}|\\\\p{Ps}]\", \"u\");\r\n}\r\ncatch (_) { }\r\nconst DefaultInline = {\r\n    Escape(cx, next, start) {\r\n        if (next != 92 /* '\\\\' */ || start == cx.end - 1)\r\n            return -1;\r\n        let escaped = cx.char(start + 1);\r\n        for (let i = 0; i < Escapable.length; i++)\r\n            if (Escapable.charCodeAt(i) == escaped)\r\n                return cx.append(elt(Type.Escape, start, start + 2));\r\n        return -1;\r\n    },\r\n    Entity(cx, next, start) {\r\n        if (next != 38 /* '&' */)\r\n            return -1;\r\n        let m = /^(?:#\\d+|#x[a-f\\d]+|\\w+);/i.exec(cx.slice(start + 1, start + 31));\r\n        return m ? cx.append(elt(Type.Entity, start, start + 1 + m[0].length)) : -1;\r\n    },\r\n    InlineCode(cx, next, start) {\r\n        if (next != 96 /* '`' */ || start && cx.char(start - 1) == 96)\r\n            return -1;\r\n        let pos = start + 1;\r\n        while (pos < cx.end && cx.char(pos) == 96)\r\n            pos++;\r\n        let size = pos - start, curSize = 0;\r\n        for (; pos < cx.end; pos++) {\r\n            if (cx.char(pos) == 96) {\r\n                curSize++;\r\n                if (curSize == size && cx.char(pos + 1) != 96)\r\n                    return cx.append(elt(Type.InlineCode, start, pos + 1, [\r\n                        elt(Type.CodeMark, start, start + size),\r\n                        elt(Type.CodeMark, pos + 1 - size, pos + 1)\r\n                    ]));\r\n            }\r\n            else {\r\n                curSize = 0;\r\n            }\r\n        }\r\n        return -1;\r\n    },\r\n    HTMLTag(cx, next, start) {\r\n        if (next != 60 /* '<' */ || start == cx.end - 1)\r\n            return -1;\r\n        let after = cx.slice(start + 1, cx.end);\r\n        let url = /^(?:[a-z][-\\w+.]+:[^\\s>]+|[a-z\\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?(?:\\.[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?)*)>/i.exec(after);\r\n        if (url) {\r\n            return cx.append(elt(Type.Autolink, start, start + 1 + url[0].length, [\r\n                elt(Type.LinkMark, start, start + 1),\r\n                // url[0] includes the closing bracket, so exclude it from this slice\r\n                elt(Type.URL, start + 1, start + url[0].length),\r\n                elt(Type.LinkMark, start + url[0].length, start + 1 + url[0].length)\r\n            ]));\r\n        }\r\n        let comment = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);\r\n        if (comment)\r\n            return cx.append(elt(Type.Comment, start, start + 1 + comment[0].length));\r\n        let procInst = /^\\?[^]*?\\?>/.exec(after);\r\n        if (procInst)\r\n            return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));\r\n        let m = /^(?:![A-Z][^]*?>|!\\[CDATA\\[[^]*?\\]\\]>|\\/\\s*[a-zA-Z][\\w-]*\\s*>|\\s*[a-zA-Z][\\w-]*(\\s+[a-zA-Z:_][\\w-.:]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*(\\/\\s*)?>)/.exec(after);\r\n        if (!m)\r\n            return -1;\r\n        return cx.append(elt(Type.HTMLTag, start, start + 1 + m[0].length));\r\n    },\r\n    Emphasis(cx, next, start) {\r\n        if (next != 95 && next != 42)\r\n            return -1;\r\n        let pos = start + 1;\r\n        while (cx.char(pos) == next)\r\n            pos++;\r\n        let before = cx.slice(start - 1, start), after = cx.slice(pos, pos + 1);\r\n        let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\r\n        let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\r\n        let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);\r\n        let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);\r\n        let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);\r\n        let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);\r\n        return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 /* Mark.Open */ : 0 /* Mark.None */) | (canClose ? 2 /* Mark.Close */ : 0 /* Mark.None */)));\r\n    },\r\n    HardBreak(cx, next, start) {\r\n        if (next == 92 /* '\\\\' */ && cx.char(start + 1) == 10 /* '\\n' */)\r\n            return cx.append(elt(Type.HardBreak, start, start + 2));\r\n        if (next == 32) {\r\n            let pos = start + 1;\r\n            while (cx.char(pos) == 32)\r\n                pos++;\r\n            if (cx.char(pos) == 10 && pos >= start + 2)\r\n                return cx.append(elt(Type.HardBreak, start, pos + 1));\r\n        }\r\n        return -1;\r\n    },\r\n    Link(cx, next, start) {\r\n        return next == 91 /* '[' */ ? cx.append(new InlineDelimiter(LinkStart, start, start + 1, 1 /* Mark.Open */)) : -1;\r\n    },\r\n    Image(cx, next, start) {\r\n        return next == 33 /* '!' */ && cx.char(start + 1) == 91 /* '[' */\r\n            ? cx.append(new InlineDelimiter(ImageStart, start, start + 2, 1 /* Mark.Open */)) : -1;\r\n    },\r\n    LinkEnd(cx, next, start) {\r\n        if (next != 93 /* ']' */)\r\n            return -1;\r\n        // Scanning back to the next link/image start marker\r\n        for (let i = cx.parts.length - 1; i >= 0; i--) {\r\n            let part = cx.parts[i];\r\n            if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {\r\n                // If this one has been set invalid (because it would produce\r\n                // a nested link) or there's no valid link here ignore both.\r\n                if (!part.side || cx.skipSpace(part.to) == start && !/[(\\[]/.test(cx.slice(start + 1, start + 2))) {\r\n                    cx.parts[i] = null;\r\n                    return -1;\r\n                }\r\n                // Finish the content and replace the entire range in\r\n                // this.parts with the link/image node.\r\n                let content = cx.takeContent(i);\r\n                let link = cx.parts[i] = finishLink(cx, content, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1);\r\n                // Set any open-link markers before this link to invalid.\r\n                if (part.type == LinkStart)\r\n                    for (let j = 0; j < i; j++) {\r\n                        let p = cx.parts[j];\r\n                        if (p instanceof InlineDelimiter && p.type == LinkStart)\r\n                            p.side = 0 /* Mark.None */;\r\n                    }\r\n                return link.to;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n};\r\nfunction finishLink(cx, content, type, start, startPos) {\r\n    let { text } = cx, next = cx.char(startPos), endPos = startPos;\r\n    content.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));\r\n    content.push(elt(Type.LinkMark, startPos - 1, startPos));\r\n    if (next == 40 /* '(' */) {\r\n        let pos = cx.skipSpace(startPos + 1);\r\n        let dest = parseURL(text, pos - cx.offset, cx.offset), title;\r\n        if (dest) {\r\n            pos = cx.skipSpace(dest.to);\r\n            // The destination and title must be separated by whitespace\r\n            if (pos != dest.to) {\r\n                title = parseLinkTitle(text, pos - cx.offset, cx.offset);\r\n                if (title)\r\n                    pos = cx.skipSpace(title.to);\r\n            }\r\n        }\r\n        if (cx.char(pos) == 41 /* ')' */) {\r\n            content.push(elt(Type.LinkMark, startPos, startPos + 1));\r\n            endPos = pos + 1;\r\n            if (dest)\r\n                content.push(dest);\r\n            if (title)\r\n                content.push(title);\r\n            content.push(elt(Type.LinkMark, pos, endPos));\r\n        }\r\n    }\r\n    else if (next == 91 /* '[' */) {\r\n        let label = parseLinkLabel(text, startPos - cx.offset, cx.offset, false);\r\n        if (label) {\r\n            content.push(label);\r\n            endPos = label.to;\r\n        }\r\n    }\r\n    return elt(type, start, endPos, content);\r\n}\r\n// These return `null` when falling off the end of the input, `false`\r\n// when parsing fails otherwise (for use in the incremental link\r\n// reference parser).\r\nfunction parseURL(text, start, offset) {\r\n    let next = text.charCodeAt(start);\r\n    if (next == 60 /* '<' */) {\r\n        for (let pos = start + 1; pos < text.length; pos++) {\r\n            let ch = text.charCodeAt(pos);\r\n            if (ch == 62 /* '>' */)\r\n                return elt(Type.URL, start + offset, pos + 1 + offset);\r\n            if (ch == 60 || ch == 10 /* '<\\n' */)\r\n                return false;\r\n        }\r\n        return null;\r\n    }\r\n    else {\r\n        let depth = 0, pos = start;\r\n        for (let escaped = false; pos < text.length; pos++) {\r\n            let ch = text.charCodeAt(pos);\r\n            if (space(ch)) {\r\n                break;\r\n            }\r\n            else if (escaped) {\r\n                escaped = false;\r\n            }\r\n            else if (ch == 40 /* '(' */) {\r\n                depth++;\r\n            }\r\n            else if (ch == 41 /* ')' */) {\r\n                if (!depth)\r\n                    break;\r\n                depth--;\r\n            }\r\n            else if (ch == 92 /* '\\\\' */) {\r\n                escaped = true;\r\n            }\r\n        }\r\n        return pos > start ? elt(Type.URL, start + offset, pos + offset) : pos == text.length ? null : false;\r\n    }\r\n}\r\nfunction parseLinkTitle(text, start, offset) {\r\n    let next = text.charCodeAt(start);\r\n    if (next != 39 && next != 34 && next != 40 /* '\"\\'(' */)\r\n        return false;\r\n    let end = next == 40 ? 41 : next;\r\n    for (let pos = start + 1, escaped = false; pos < text.length; pos++) {\r\n        let ch = text.charCodeAt(pos);\r\n        if (escaped)\r\n            escaped = false;\r\n        else if (ch == end)\r\n            return elt(Type.LinkTitle, start + offset, pos + 1 + offset);\r\n        else if (ch == 92 /* '\\\\' */)\r\n            escaped = true;\r\n    }\r\n    return null;\r\n}\r\nfunction parseLinkLabel(text, start, offset, requireNonWS) {\r\n    for (let escaped = false, pos = start + 1, end = Math.min(text.length, pos + 999); pos < end; pos++) {\r\n        let ch = text.charCodeAt(pos);\r\n        if (escaped)\r\n            escaped = false;\r\n        else if (ch == 93 /* ']' */)\r\n            return requireNonWS ? false : elt(Type.LinkLabel, start + offset, pos + 1 + offset);\r\n        else {\r\n            if (requireNonWS && !space(ch))\r\n                requireNonWS = false;\r\n            if (ch == 91 /* '[' */)\r\n                return false;\r\n            else if (ch == 92 /* '\\\\' */)\r\n                escaped = true;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n/// Inline parsing functions get access to this context, and use it to\r\n/// read the content and emit syntax nodes.\r\nclass InlineContext {\r\n    /// @internal\r\n    constructor(\r\n    /// The parser that is being used.\r\n    parser, \r\n    /// The text of this inline section.\r\n    text, \r\n    /// The starting offset of the section in the document.\r\n    offset) {\r\n        this.parser = parser;\r\n        this.text = text;\r\n        this.offset = offset;\r\n        /// @internal\r\n        this.parts = [];\r\n    }\r\n    /// Get the character code at the given (document-relative)\r\n    /// position.\r\n    char(pos) { return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset); }\r\n    /// The position of the end of this inline section.\r\n    get end() { return this.offset + this.text.length; }\r\n    /// Get a substring of this inline section. Again uses\r\n    /// document-relative positions.\r\n    slice(from, to) { return this.text.slice(from - this.offset, to - this.offset); }\r\n    /// @internal\r\n    append(elt) {\r\n        this.parts.push(elt);\r\n        return elt.to;\r\n    }\r\n    /// Add a [delimiter](#DelimiterType) at this given position. `open`\r\n    /// and `close` indicate whether this delimiter is opening, closing,\r\n    /// or both. Returns the end of the delimiter, for convenient\r\n    /// returning from [parse functions](#InlineParser.parse).\r\n    addDelimiter(type, from, to, open, close) {\r\n        return this.append(new InlineDelimiter(type, from, to, (open ? 1 /* Mark.Open */ : 0 /* Mark.None */) | (close ? 2 /* Mark.Close */ : 0 /* Mark.None */)));\r\n    }\r\n    /// Returns true when there is an unmatched link or image opening\r\n    /// token before the current position.\r\n    get hasOpenLink() {\r\n        for (let i = this.parts.length - 1; i >= 0; i--) {\r\n            let part = this.parts[i];\r\n            if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart))\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    /// Add an inline element. Returns the end of the element.\r\n    addElement(elt) {\r\n        return this.append(elt);\r\n    }\r\n    /// Resolve markers between this.parts.length and from, wrapping matched markers in the\r\n    /// appropriate node and updating the content of this.parts. @internal\r\n    resolveMarkers(from) {\r\n        // Scan forward, looking for closing tokens\r\n        for (let i = from; i < this.parts.length; i++) {\r\n            let close = this.parts[i];\r\n            if (!(close instanceof InlineDelimiter && close.type.resolve && (close.side & 2 /* Mark.Close */)))\r\n                continue;\r\n            let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;\r\n            let closeSize = close.to - close.from;\r\n            let open, j = i - 1;\r\n            // Continue scanning for a matching opening token\r\n            for (; j >= from; j--) {\r\n                let part = this.parts[j];\r\n                if (part instanceof InlineDelimiter && (part.side & 1 /* Mark.Open */) && part.type == close.type &&\r\n                    // Ignore emphasis delimiters where the character count doesn't match\r\n                    !(emp && ((close.side & 1 /* Mark.Open */) || (part.side & 2 /* Mark.Close */)) &&\r\n                        (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3))) {\r\n                    open = part;\r\n                    break;\r\n                }\r\n            }\r\n            if (!open)\r\n                continue;\r\n            let type = close.type.resolve, content = [];\r\n            let start = open.from, end = close.to;\r\n            // Emphasis marker effect depends on the character count. Size consumed is minimum of the two\r\n            // markers.\r\n            if (emp) {\r\n                let size = Math.min(2, open.to - open.from, closeSize);\r\n                start = open.to - size;\r\n                end = close.from + size;\r\n                type = size == 1 ? \"Emphasis\" : \"StrongEmphasis\";\r\n            }\r\n            // Move the covered region into content, optionally adding marker nodes\r\n            if (open.type.mark)\r\n                content.push(this.elt(open.type.mark, start, open.to));\r\n            for (let k = j + 1; k < i; k++) {\r\n                if (this.parts[k] instanceof Element)\r\n                    content.push(this.parts[k]);\r\n                this.parts[k] = null;\r\n            }\r\n            if (close.type.mark)\r\n                content.push(this.elt(close.type.mark, close.from, end));\r\n            let element = this.elt(type, start, end, content);\r\n            // If there are leftover emphasis marker characters, shrink the close/open markers. Otherwise, clear them.\r\n            this.parts[j] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;\r\n            let keep = this.parts[i] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;\r\n            // Insert the new element in this.parts\r\n            if (keep)\r\n                this.parts.splice(i, 0, element);\r\n            else\r\n                this.parts[i] = element;\r\n        }\r\n        // Collect the elements remaining in this.parts into an array.\r\n        let result = [];\r\n        for (let i = from; i < this.parts.length; i++) {\r\n            let part = this.parts[i];\r\n            if (part instanceof Element)\r\n                result.push(part);\r\n        }\r\n        return result;\r\n    }\r\n    /// Find an opening delimiter of the given type. Returns `null` if\r\n    /// no delimiter is found, or an index that can be passed to\r\n    /// [`takeContent`](#InlineContext.takeContent) otherwise.\r\n    findOpeningDelimiter(type) {\r\n        for (let i = this.parts.length - 1; i >= 0; i--) {\r\n            let part = this.parts[i];\r\n            if (part instanceof InlineDelimiter && part.type == type)\r\n                return i;\r\n        }\r\n        return null;\r\n    }\r\n    /// Remove all inline elements and delimiters starting from the\r\n    /// given index (which you should get from\r\n    /// [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),\r\n    /// resolve delimiters inside of them, and return them as an array\r\n    /// of elements.\r\n    takeContent(startIndex) {\r\n        let content = this.resolveMarkers(startIndex);\r\n        this.parts.length = startIndex;\r\n        return content;\r\n    }\r\n    /// Skip space after the given (document) position, returning either\r\n    /// the position of the next non-space character or the end of the\r\n    /// section.\r\n    skipSpace(from) { return skipSpace(this.text, from - this.offset) + this.offset; }\r\n    elt(type, from, to, children) {\r\n        if (typeof type == \"string\")\r\n            return elt(this.parser.getNodeType(type), from, to, children);\r\n        return new TreeElement(type, from);\r\n    }\r\n}\r\nfunction injectMarks(elements, marks) {\r\n    if (!marks.length)\r\n        return elements;\r\n    if (!elements.length)\r\n        return marks;\r\n    let elts = elements.slice(), eI = 0;\r\n    for (let mark of marks) {\r\n        while (eI < elts.length && elts[eI].to < mark.to)\r\n            eI++;\r\n        if (eI < elts.length && elts[eI].from < mark.from) {\r\n            let e = elts[eI];\r\n            if (e instanceof Element)\r\n                elts[eI] = new Element(e.type, e.from, e.to, injectMarks(e.children, [mark]));\r\n        }\r\n        else {\r\n            elts.splice(eI++, 0, mark);\r\n        }\r\n    }\r\n    return elts;\r\n}\r\n// These are blocks that can span blank lines, and should thus only be\r\n// reused if their next sibling is also being reused.\r\nconst NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];\r\nclass FragmentCursor {\r\n    constructor(fragments, input) {\r\n        this.fragments = fragments;\r\n        this.input = input;\r\n        // Index into fragment array\r\n        this.i = 0;\r\n        // Active fragment\r\n        this.fragment = null;\r\n        this.fragmentEnd = -1;\r\n        // Cursor into the current fragment, if any. When `moveTo` returns\r\n        // true, this points at the first block after `pos`.\r\n        this.cursor = null;\r\n        if (fragments.length)\r\n            this.fragment = fragments[this.i++];\r\n    }\r\n    nextFragment() {\r\n        this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;\r\n        this.cursor = null;\r\n        this.fragmentEnd = -1;\r\n    }\r\n    moveTo(pos, lineStart) {\r\n        while (this.fragment && this.fragment.to <= pos)\r\n            this.nextFragment();\r\n        if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0))\r\n            return false;\r\n        if (this.fragmentEnd < 0) {\r\n            let end = this.fragment.to;\r\n            while (end > 0 && this.input.read(end - 1, end) != \"\\n\")\r\n                end--;\r\n            this.fragmentEnd = end ? end - 1 : 0;\r\n        }\r\n        let c = this.cursor;\r\n        if (!c) {\r\n            c = this.cursor = this.fragment.tree.cursor();\r\n            c.firstChild();\r\n        }\r\n        let rPos = pos + this.fragment.offset;\r\n        while (c.to <= rPos)\r\n            if (!c.parent())\r\n                return false;\r\n        for (;;) {\r\n            if (c.from >= rPos)\r\n                return this.fragment.from <= lineStart;\r\n            if (!c.childAfter(rPos))\r\n                return false;\r\n        }\r\n    }\r\n    matches(hash) {\r\n        let tree = this.cursor.tree;\r\n        return tree && tree.prop(NodeProp.contextHash) == hash;\r\n    }\r\n    takeNodes(cx) {\r\n        let cur = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);\r\n        let start = cx.absoluteLineStart, end = start, blockI = cx.block.children.length;\r\n        let prevEnd = end, prevI = blockI;\r\n        for (;;) {\r\n            if (cur.to - off > fragEnd) {\r\n                if (cur.type.isAnonymous && cur.firstChild())\r\n                    continue;\r\n                break;\r\n            }\r\n            let pos = toRelative(cur.from - off, cx.ranges);\r\n            if (cur.to - off <= cx.ranges[cx.rangeI].to) { // Fits in current range\r\n                cx.addNode(cur.tree, pos);\r\n            }\r\n            else {\r\n                let dummy = new Tree(cx.parser.nodeSet.types[Type.Paragraph], [], [], 0, cx.block.hashProp);\r\n                cx.reusePlaceholders.set(dummy, cur.tree);\r\n                cx.addNode(dummy, pos);\r\n            }\r\n            // Taken content must always end in a block, because incremental\r\n            // parsing happens on block boundaries. Never stop directly\r\n            // after an indented code block, since those can continue after\r\n            // any number of blank lines.\r\n            if (cur.type.is(\"Block\")) {\r\n                if (NotLast.indexOf(cur.type.id) < 0) {\r\n                    end = cur.to - off;\r\n                    blockI = cx.block.children.length;\r\n                }\r\n                else {\r\n                    end = prevEnd;\r\n                    blockI = prevI;\r\n                    prevEnd = cur.to - off;\r\n                    prevI = cx.block.children.length;\r\n                }\r\n            }\r\n            if (!cur.nextSibling())\r\n                break;\r\n        }\r\n        while (cx.block.children.length > blockI) {\r\n            cx.block.children.pop();\r\n            cx.block.positions.pop();\r\n        }\r\n        return end - start;\r\n    }\r\n}\r\n// Convert an input-stream-relative position to a\r\n// Markdown-doc-relative position by subtracting the size of all input\r\n// gaps before `abs`.\r\nfunction toRelative(abs, ranges) {\r\n    let pos = abs;\r\n    for (let i = 1; i < ranges.length; i++) {\r\n        let gapFrom = ranges[i - 1].to, gapTo = ranges[i].from;\r\n        if (gapFrom < abs)\r\n            pos -= gapTo - gapFrom;\r\n    }\r\n    return pos;\r\n}\r\nconst markdownHighlighting = styleTags({\r\n    \"Blockquote/...\": tags.quote,\r\n    HorizontalRule: tags.contentSeparator,\r\n    \"ATXHeading1/... SetextHeading1/...\": tags.heading1,\r\n    \"ATXHeading2/... SetextHeading2/...\": tags.heading2,\r\n    \"ATXHeading3/...\": tags.heading3,\r\n    \"ATXHeading4/...\": tags.heading4,\r\n    \"ATXHeading5/...\": tags.heading5,\r\n    \"ATXHeading6/...\": tags.heading6,\r\n    \"Comment CommentBlock\": tags.comment,\r\n    Escape: tags.escape,\r\n    Entity: tags.character,\r\n    \"Emphasis/...\": tags.emphasis,\r\n    \"StrongEmphasis/...\": tags.strong,\r\n    \"Link/... Image/...\": tags.link,\r\n    \"OrderedList/... BulletList/...\": tags.list,\r\n    \"BlockQuote/...\": tags.quote,\r\n    \"InlineCode CodeText\": tags.monospace,\r\n    \"URL Autolink\": tags.url,\r\n    \"HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark\": tags.processingInstruction,\r\n    \"CodeInfo LinkLabel\": tags.labelName,\r\n    LinkTitle: tags.string,\r\n    Paragraph: tags.content\r\n});\r\n/// The default CommonMark parser.\r\nconst parser = new MarkdownParser(new NodeSet(nodeTypes).extend(markdownHighlighting), Object.keys(DefaultBlockParsers).map(n => DefaultBlockParsers[n]), Object.keys(DefaultBlockParsers).map(n => DefaultLeafBlocks[n]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map(n => DefaultInline[n]), Object.keys(DefaultInline), []);\r\n\r\nfunction leftOverSpace(node, from, to) {\r\n    let ranges = [];\r\n    for (let n = node.firstChild, pos = from;; n = n.nextSibling) {\r\n        let nextPos = n ? n.from : to;\r\n        if (nextPos > pos)\r\n            ranges.push({ from: pos, to: nextPos });\r\n        if (!n)\r\n            break;\r\n        pos = n.to;\r\n    }\r\n    return ranges;\r\n}\r\n/// Create a Markdown extension to enable nested parsing on code\r\n/// blocks and/or embedded HTML.\r\nfunction parseCode(config) {\r\n    let { codeParser, htmlParser } = config;\r\n    let wrap = parseMixed((node, input) => {\r\n        let id = node.type.id;\r\n        if (codeParser && (id == Type.CodeBlock || id == Type.FencedCode)) {\r\n            let info = \"\";\r\n            if (id == Type.FencedCode) {\r\n                let infoNode = node.node.getChild(Type.CodeInfo);\r\n                if (infoNode)\r\n                    info = input.read(infoNode.from, infoNode.to);\r\n            }\r\n            let parser = codeParser(info);\r\n            if (parser)\r\n                return { parser, overlay: node => node.type.id == Type.CodeText };\r\n        }\r\n        else if (htmlParser && (id == Type.HTMLBlock || id == Type.HTMLTag)) {\r\n            return { parser: htmlParser, overlay: leftOverSpace(node.node, node.from, node.to) };\r\n        }\r\n        return null;\r\n    });\r\n    return { wrap };\r\n}\r\n\r\nconst StrikethroughDelim = { resolve: \"Strikethrough\", mark: \"StrikethroughMark\" };\r\n/// An extension that implements\r\n/// [GFM-style](https://github.github.com/gfm/#strikethrough-extension-)\r\n/// Strikethrough syntax using `~~` delimiters.\r\nconst Strikethrough = {\r\n    defineNodes: [{\r\n            name: \"Strikethrough\",\r\n            style: { \"Strikethrough/...\": tags.strikethrough }\r\n        }, {\r\n            name: \"StrikethroughMark\",\r\n            style: tags.processingInstruction\r\n        }],\r\n    parseInline: [{\r\n            name: \"Strikethrough\",\r\n            parse(cx, next, pos) {\r\n                if (next != 126 /* '~' */ || cx.char(pos + 1) != 126 || cx.char(pos + 2) == 126)\r\n                    return -1;\r\n                let before = cx.slice(pos - 1, pos), after = cx.slice(pos + 2, pos + 3);\r\n                let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\r\n                let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\r\n                return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, !sAfter && (!pAfter || sBefore || pBefore), !sBefore && (!pBefore || sAfter || pAfter));\r\n            },\r\n            after: \"Emphasis\"\r\n        }]\r\n};\r\nfunction parseRow(cx, line, startI = 0, elts, offset = 0) {\r\n    let count = 0, first = true, cellStart = -1, cellEnd = -1, esc = false;\r\n    let parseCell = () => {\r\n        elts.push(cx.elt(\"TableCell\", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)));\r\n    };\r\n    for (let i = startI; i < line.length; i++) {\r\n        let next = line.charCodeAt(i);\r\n        if (next == 124 /* '|' */ && !esc) {\r\n            if (!first || cellStart > -1)\r\n                count++;\r\n            first = false;\r\n            if (elts) {\r\n                if (cellStart > -1)\r\n                    parseCell();\r\n                elts.push(cx.elt(\"TableDelimiter\", i + offset, i + offset + 1));\r\n            }\r\n            cellStart = cellEnd = -1;\r\n        }\r\n        else if (esc || next != 32 && next != 9) {\r\n            if (cellStart < 0)\r\n                cellStart = i;\r\n            cellEnd = i + 1;\r\n        }\r\n        esc = !esc && next == 92;\r\n    }\r\n    if (cellStart > -1) {\r\n        count++;\r\n        if (elts)\r\n            parseCell();\r\n    }\r\n    return count;\r\n}\r\nfunction hasPipe(str, start) {\r\n    for (let i = start; i < str.length; i++) {\r\n        let next = str.charCodeAt(i);\r\n        if (next == 124 /* '|' */)\r\n            return true;\r\n        if (next == 92 /* '\\\\' */)\r\n            i++;\r\n    }\r\n    return false;\r\n}\r\nconst delimiterLine = /^\\|?(\\s*:?-+:?\\s*\\|)+(\\s*:?-+:?\\s*)?$/;\r\nclass TableParser {\r\n    constructor() {\r\n        // Null means we haven't seen the second line yet, false means this\r\n        // isn't a table, and an array means this is a table and we've\r\n        // parsed the given rows so far.\r\n        this.rows = null;\r\n    }\r\n    nextLine(cx, line, leaf) {\r\n        if (this.rows == null) { // Second line\r\n            this.rows = false;\r\n            let lineText;\r\n            if ((line.next == 45 || line.next == 58 || line.next == 124 /* '-:|' */) &&\r\n                delimiterLine.test(lineText = line.text.slice(line.pos))) {\r\n                let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);\r\n                if (firstCount == parseRow(cx, lineText, line.pos))\r\n                    this.rows = [cx.elt(\"TableHeader\", leaf.start, leaf.start + leaf.content.length, firstRow),\r\n                        cx.elt(\"TableDelimiter\", cx.lineStart + line.pos, cx.lineStart + line.text.length)];\r\n            }\r\n        }\r\n        else if (this.rows) { // Line after the second\r\n            let content = [];\r\n            parseRow(cx, line.text, line.pos, content, cx.lineStart);\r\n            this.rows.push(cx.elt(\"TableRow\", cx.lineStart + line.pos, cx.lineStart + line.text.length, content));\r\n        }\r\n        return false;\r\n    }\r\n    finish(cx, leaf) {\r\n        if (!this.rows)\r\n            return false;\r\n        cx.addLeafElement(leaf, cx.elt(\"Table\", leaf.start, leaf.start + leaf.content.length, this.rows));\r\n        return true;\r\n    }\r\n}\r\n/// This extension provides\r\n/// [GFM-style](https://github.github.com/gfm/#tables-extension-)\r\n/// tables, using syntax like this:\r\n///\r\n/// ```\r\n/// | head 1 | head 2 |\r\n/// | ---    | ---    |\r\n/// | cell 1 | cell 2 |\r\n/// ```\r\nconst Table = {\r\n    defineNodes: [\r\n        { name: \"Table\", block: true },\r\n        { name: \"TableHeader\", style: { \"TableHeader/...\": tags.heading } },\r\n        \"TableRow\",\r\n        { name: \"TableCell\", style: tags.content },\r\n        { name: \"TableDelimiter\", style: tags.processingInstruction },\r\n    ],\r\n    parseBlock: [{\r\n            name: \"Table\",\r\n            leaf(_, leaf) { return hasPipe(leaf.content, 0) ? new TableParser : null; },\r\n            endLeaf(cx, line, leaf) {\r\n                if (leaf.parsers.some(p => p instanceof TableParser) || !hasPipe(line.text, line.basePos))\r\n                    return false;\r\n                let next = cx.scanLine(cx.absoluteLineEnd + 1).text;\r\n                return delimiterLine.test(next) && parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos);\r\n            },\r\n            before: \"SetextHeading\"\r\n        }]\r\n};\r\nclass TaskParser {\r\n    nextLine() { return false; }\r\n    finish(cx, leaf) {\r\n        cx.addLeafElement(leaf, cx.elt(\"Task\", leaf.start, leaf.start + leaf.content.length, [\r\n            cx.elt(\"TaskMarker\", leaf.start, leaf.start + 3),\r\n            ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)\r\n        ]));\r\n        return true;\r\n    }\r\n}\r\n/// Extension providing\r\n/// [GFM-style](https://github.github.com/gfm/#task-list-items-extension-)\r\n/// task list items, where list items can be prefixed with `[ ]` or\r\n/// `[x]` to add a checkbox.\r\nconst TaskList = {\r\n    defineNodes: [\r\n        { name: \"Task\", block: true, style: tags.list },\r\n        { name: \"TaskMarker\", style: tags.atom }\r\n    ],\r\n    parseBlock: [{\r\n            name: \"TaskList\",\r\n            leaf(cx, leaf) {\r\n                return /^\\[[ xX]\\][ \\t]/.test(leaf.content) && cx.parentType().name == \"ListItem\" ? new TaskParser : null;\r\n            },\r\n            after: \"SetextHeading\"\r\n        }]\r\n};\r\nconst autolinkRE = /(www\\.)|(https?:\\/\\/)|([\\w.+-]+@)|(mailto:|xmpp:)/gy;\r\nconst urlRE = /[\\w-]+(\\.[\\w-]+)+(\\/[^\\s<]*)?/gy;\r\nconst lastTwoDomainWords = /[\\w-]+\\.[\\w-]+($|\\/)/;\r\nconst emailRE = /[\\w.+-]+@[\\w-]+(\\.[\\w.-]+)+/gy;\r\nconst xmppResourceRE = /\\/[a-zA-Z\\d@.]+/gy;\r\nfunction count(str, from, to, ch) {\r\n    let result = 0;\r\n    for (let i = from; i < to; i++)\r\n        if (str[i] == ch)\r\n            result++;\r\n    return result;\r\n}\r\nfunction autolinkURLEnd(text, from) {\r\n    urlRE.lastIndex = from;\r\n    let m = urlRE.exec(text);\r\n    if (!m || lastTwoDomainWords.exec(m[0])[0].indexOf(\"_\") > -1)\r\n        return -1;\r\n    let end = from + m[0].length;\r\n    for (;;) {\r\n        let last = text[end - 1], m;\r\n        if (/[?!.,:*_~]/.test(last) ||\r\n            last == \")\" && count(text, from, end, \")\") > count(text, from, end, \"(\"))\r\n            end--;\r\n        else if (last == \";\" && (m = /&(?:#\\d+|#x[a-f\\d]+|\\w+);$/.exec(text.slice(from, end))))\r\n            end = from + m.index;\r\n        else\r\n            break;\r\n    }\r\n    return end;\r\n}\r\nfunction autolinkEmailEnd(text, from) {\r\n    emailRE.lastIndex = from;\r\n    let m = emailRE.exec(text);\r\n    if (!m)\r\n        return -1;\r\n    let last = m[0][m[0].length - 1];\r\n    return last == \"_\" || last == \"-\" ? -1 : from + m[0].length - (last == \".\" ? 1 : 0);\r\n}\r\n/// Extension that implements autolinking for\r\n/// `www.`/`http://`/`https://`/`mailto:`/`xmpp:` URLs and email\r\n/// addresses.\r\nconst Autolink = {\r\n    parseInline: [{\r\n            name: \"Autolink\",\r\n            parse(cx, next, absPos) {\r\n                let pos = absPos - cx.offset;\r\n                autolinkRE.lastIndex = pos;\r\n                let m = autolinkRE.exec(cx.text), end = -1;\r\n                if (!m)\r\n                    return -1;\r\n                if (m[1] || m[2]) { // www., http://\r\n                    end = autolinkURLEnd(cx.text, pos + m[0].length);\r\n                    if (end > -1 && cx.hasOpenLink) {\r\n                        let noBracket = /([^\\[\\]]|\\[[^\\]]*\\])*/.exec(cx.text.slice(pos, end));\r\n                        end = pos + noBracket[0].length;\r\n                    }\r\n                }\r\n                else if (m[3]) { // email address\r\n                    end = autolinkEmailEnd(cx.text, pos);\r\n                }\r\n                else { // mailto:/xmpp:\r\n                    end = autolinkEmailEnd(cx.text, pos + m[0].length);\r\n                    if (end > -1 && m[0] == \"xmpp:\") {\r\n                        xmppResourceRE.lastIndex = end;\r\n                        m = xmppResourceRE.exec(cx.text);\r\n                        if (m)\r\n                            end = m.index + m[0].length;\r\n                    }\r\n                }\r\n                if (end < 0)\r\n                    return -1;\r\n                cx.addElement(cx.elt(\"URL\", absPos, end + cx.offset));\r\n                return end + cx.offset;\r\n            }\r\n        }]\r\n};\r\n/// Extension bundle containing [`Table`](#Table),\r\n/// [`TaskList`](#TaskList), [`Strikethrough`](#Strikethrough), and\r\n/// [`Autolink`](#Autolink).\r\nconst GFM = [Table, TaskList, Strikethrough, Autolink];\r\nfunction parseSubSuper(ch, node, mark) {\r\n    return (cx, next, pos) => {\r\n        if (next != ch || cx.char(pos + 1) == ch)\r\n            return -1;\r\n        let elts = [cx.elt(mark, pos, pos + 1)];\r\n        for (let i = pos + 1; i < cx.end; i++) {\r\n            let next = cx.char(i);\r\n            if (next == ch)\r\n                return cx.addElement(cx.elt(node, pos, i + 1, elts.concat(cx.elt(mark, i, i + 1))));\r\n            if (next == 92 /* '\\\\' */)\r\n                elts.push(cx.elt(\"Escape\", i, i++ + 2));\r\n            if (space(next))\r\n                break;\r\n        }\r\n        return -1;\r\n    };\r\n}\r\n/// Extension providing\r\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\r\n/// superscript using `^` markers.\r\nconst Superscript = {\r\n    defineNodes: [\r\n        { name: \"Superscript\", style: tags.special(tags.content) },\r\n        { name: \"SuperscriptMark\", style: tags.processingInstruction }\r\n    ],\r\n    parseInline: [{\r\n            name: \"Superscript\",\r\n            parse: parseSubSuper(94 /* '^' */, \"Superscript\", \"SuperscriptMark\")\r\n        }]\r\n};\r\n/// Extension providing\r\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\r\n/// subscript using `~` markers.\r\nconst Subscript = {\r\n    defineNodes: [\r\n        { name: \"Subscript\", style: tags.special(tags.content) },\r\n        { name: \"SubscriptMark\", style: tags.processingInstruction }\r\n    ],\r\n    parseInline: [{\r\n            name: \"Subscript\",\r\n            parse: parseSubSuper(126 /* '~' */, \"Subscript\", \"SubscriptMark\")\r\n        }]\r\n};\r\n/// Extension that parses two colons with only letters, underscores,\r\n/// and numbers between them as `Emoji` nodes.\r\nconst Emoji = {\r\n    defineNodes: [{ name: \"Emoji\", style: tags.character }],\r\n    parseInline: [{\r\n            name: \"Emoji\",\r\n            parse(cx, next, pos) {\r\n                let match;\r\n                if (next != 58 /* ':' */ || !(match = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))\r\n                    return -1;\r\n                return cx.addElement(cx.elt(\"Emoji\", pos, pos + 1 + match[0].length));\r\n            }\r\n        }]\r\n};\r\n\r\nexport { Autolink, BlockContext, Element, Emoji, GFM, InlineContext, LeafBlock, Line, MarkdownParser, Strikethrough, Subscript, Superscript, Table, TaskList, parseCode, parser };\r\n", "import { EditorSelection, countColumn, Prec, EditorState } from '@codemirror/state';\r\nimport { keymap } from '@codemirror/view';\r\nimport { defineLanguageFacet, foldNodeProp, indentNodeProp, languageDataProp, foldService, syntaxTree, Language, LanguageDescription, ParseContext, indentUnit, LanguageSupport } from '@codemirror/language';\r\nimport { CompletionContext } from '@codemirror/autocomplete';\r\nimport { parser, GFM, Subscript, Superscript, Emoji, MarkdownParser, parseCode } from '@lezer/markdown';\r\nimport { html, htmlCompletionSource } from '@codemirror/lang-html';\r\nimport { NodeProp } from '@lezer/common';\r\n\r\nconst data = /*@__PURE__*/defineLanguageFacet({ commentTokens: { block: { open: \"<!--\", close: \"-->\" } } });\r\nconst headingProp = /*@__PURE__*/new NodeProp();\r\nconst commonmark = /*@__PURE__*/parser.configure({\r\n    props: [\r\n        /*@__PURE__*/foldNodeProp.add(type => {\r\n            return !type.is(\"Block\") || type.is(\"Document\") || isHeading(type) != null || isList(type) ? undefined\r\n                : (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to });\r\n        }),\r\n        /*@__PURE__*/headingProp.add(isHeading),\r\n        /*@__PURE__*/indentNodeProp.add({\r\n            Document: () => null\r\n        }),\r\n        /*@__PURE__*/languageDataProp.add({\r\n            Document: data\r\n        })\r\n    ]\r\n});\r\nfunction isHeading(type) {\r\n    let match = /^(?:ATX|Setext)Heading(\\d)$/.exec(type.name);\r\n    return match ? +match[1] : undefined;\r\n}\r\nfunction isList(type) {\r\n    return type.name == \"OrderedList\" || type.name == \"BulletList\";\r\n}\r\nfunction findSectionEnd(headerNode, level) {\r\n    let last = headerNode;\r\n    for (;;) {\r\n        let next = last.nextSibling, heading;\r\n        if (!next || (heading = isHeading(next.type)) != null && heading <= level)\r\n            break;\r\n        last = next;\r\n    }\r\n    return last.to;\r\n}\r\nconst headerIndent = /*@__PURE__*/foldService.of((state, start, end) => {\r\n    for (let node = syntaxTree(state).resolveInner(end, -1); node; node = node.parent) {\r\n        if (node.from < start)\r\n            break;\r\n        let heading = node.type.prop(headingProp);\r\n        if (heading == null)\r\n            continue;\r\n        let upto = findSectionEnd(node, heading);\r\n        if (upto > end)\r\n            return { from: end, to: upto };\r\n    }\r\n    return null;\r\n});\r\nfunction mkLang(parser) {\r\n    return new Language(data, parser, [headerIndent], \"markdown\");\r\n}\r\n/**\r\nLanguage support for strict CommonMark.\r\n*/\r\nconst commonmarkLanguage = /*@__PURE__*/mkLang(commonmark);\r\nconst extended = /*@__PURE__*/commonmark.configure([GFM, Subscript, Superscript, Emoji, {\r\n        props: [\r\n            /*@__PURE__*/foldNodeProp.add({\r\n                Table: (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to })\r\n            })\r\n        ]\r\n    }]);\r\n/**\r\nLanguage support for [GFM](https://github.github.com/gfm/) plus\r\nsubscript, superscript, and emoji syntax.\r\n*/\r\nconst markdownLanguage = /*@__PURE__*/mkLang(extended);\r\nfunction getCodeParser(languages, defaultLanguage) {\r\n    return (info) => {\r\n        if (info && languages) {\r\n            let found = null;\r\n            // Strip anything after whitespace\r\n            info = /\\S*/.exec(info)[0];\r\n            if (typeof languages == \"function\")\r\n                found = languages(info);\r\n            else\r\n                found = LanguageDescription.matchLanguageName(languages, info, true);\r\n            if (found instanceof LanguageDescription)\r\n                return found.support ? found.support.language.parser : ParseContext.getSkippingParser(found.load());\r\n            else if (found)\r\n                return found.parser;\r\n        }\r\n        return defaultLanguage ? defaultLanguage.parser : null;\r\n    };\r\n}\r\n\r\nclass Context {\r\n    constructor(node, from, to, spaceBefore, spaceAfter, type, item) {\r\n        this.node = node;\r\n        this.from = from;\r\n        this.to = to;\r\n        this.spaceBefore = spaceBefore;\r\n        this.spaceAfter = spaceAfter;\r\n        this.type = type;\r\n        this.item = item;\r\n    }\r\n    blank(maxWidth, trailing = true) {\r\n        let result = this.spaceBefore + (this.node.name == \"Blockquote\" ? \">\" : \"\");\r\n        if (maxWidth != null) {\r\n            while (result.length < maxWidth)\r\n                result += \" \";\r\n            return result;\r\n        }\r\n        else {\r\n            for (let i = this.to - this.from - result.length - this.spaceAfter.length; i > 0; i--)\r\n                result += \" \";\r\n            return result + (trailing ? this.spaceAfter : \"\");\r\n        }\r\n    }\r\n    marker(doc, add) {\r\n        let number = this.node.name == \"OrderedList\" ? String((+itemNumber(this.item, doc)[2] + add)) : \"\";\r\n        return this.spaceBefore + number + this.type + this.spaceAfter;\r\n    }\r\n}\r\nfunction getContext(node, doc) {\r\n    let nodes = [];\r\n    for (let cur = node; cur && cur.name != \"Document\"; cur = cur.parent) {\r\n        if (cur.name == \"ListItem\" || cur.name == \"Blockquote\" || cur.name == \"FencedCode\")\r\n            nodes.push(cur);\r\n    }\r\n    let context = [];\r\n    for (let i = nodes.length - 1; i >= 0; i--) {\r\n        let node = nodes[i], match;\r\n        let line = doc.lineAt(node.from), startPos = node.from - line.from;\r\n        if (node.name == \"FencedCode\") {\r\n            context.push(new Context(node, startPos, startPos, \"\", \"\", \"\", null));\r\n        }\r\n        else if (node.name == \"Blockquote\" && (match = /^ *>( ?)/.exec(line.text.slice(startPos)))) {\r\n            context.push(new Context(node, startPos, startPos + match[0].length, \"\", match[1], \">\", null));\r\n        }\r\n        else if (node.name == \"ListItem\" && node.parent.name == \"OrderedList\" &&\r\n            (match = /^( *)\\d+([.)])( *)/.exec(line.text.slice(startPos)))) {\r\n            let after = match[3], len = match[0].length;\r\n            if (after.length >= 4) {\r\n                after = after.slice(0, after.length - 4);\r\n                len -= 4;\r\n            }\r\n            context.push(new Context(node.parent, startPos, startPos + len, match[1], after, match[2], node));\r\n        }\r\n        else if (node.name == \"ListItem\" && node.parent.name == \"BulletList\" &&\r\n            (match = /^( *)([-+*])( {1,4}\\[[ xX]\\])?( +)/.exec(line.text.slice(startPos)))) {\r\n            let after = match[4], len = match[0].length;\r\n            if (after.length > 4) {\r\n                after = after.slice(0, after.length - 4);\r\n                len -= 4;\r\n            }\r\n            let type = match[2];\r\n            if (match[3])\r\n                type += match[3].replace(/[xX]/, ' ');\r\n            context.push(new Context(node.parent, startPos, startPos + len, match[1], after, type, node));\r\n        }\r\n    }\r\n    return context;\r\n}\r\nfunction itemNumber(item, doc) {\r\n    return /^(\\s*)(\\d+)(?=[.)])/.exec(doc.sliceString(item.from, item.from + 10));\r\n}\r\nfunction renumberList(after, doc, changes, offset = 0) {\r\n    for (let prev = -1, node = after;;) {\r\n        if (node.name == \"ListItem\") {\r\n            let m = itemNumber(node, doc);\r\n            let number = +m[2];\r\n            if (prev >= 0) {\r\n                if (number != prev + 1)\r\n                    return;\r\n                changes.push({ from: node.from + m[1].length, to: node.from + m[0].length, insert: String(prev + 2 + offset) });\r\n            }\r\n            prev = number;\r\n        }\r\n        let next = node.nextSibling;\r\n        if (!next)\r\n            break;\r\n        node = next;\r\n    }\r\n}\r\nfunction normalizeIndent(content, state) {\r\n    let blank = /^[ \\t]*/.exec(content)[0].length;\r\n    if (!blank || state.facet(indentUnit) != \"\\t\")\r\n        return content;\r\n    let col = countColumn(content, 4, blank);\r\n    let space = \"\";\r\n    for (let i = col; i > 0;) {\r\n        if (i >= 4) {\r\n            space += \"\\t\";\r\n            i -= 4;\r\n        }\r\n        else {\r\n            space += \" \";\r\n            i--;\r\n        }\r\n    }\r\n    return space + content.slice(blank);\r\n}\r\n/**\r\nThis command, when invoked in Markdown context with cursor\r\nselection(s), will create a new line with the markup for\r\nblockquotes and lists that were active on the old line. If the\r\ncursor was directly after the end of the markup for the old line,\r\ntrailing whitespace and list markers are removed from that line.\r\n\r\nThe command does nothing in non-Markdown context, so it should\r\nnot be used as the only binding for Enter (even in a Markdown\r\ndocument, HTML and code regions might use a different language).\r\n*/\r\nconst insertNewlineContinueMarkup = ({ state, dispatch }) => {\r\n    let tree = syntaxTree(state), { doc } = state;\r\n    let dont = null, changes = state.changeByRange(range => {\r\n        if (!range.empty || !markdownLanguage.isActiveAt(state, range.from))\r\n            return dont = { range };\r\n        let pos = range.from, line = doc.lineAt(pos);\r\n        let context = getContext(tree.resolveInner(pos, -1), doc);\r\n        while (context.length && context[context.length - 1].from > pos - line.from)\r\n            context.pop();\r\n        if (!context.length)\r\n            return dont = { range };\r\n        let inner = context[context.length - 1];\r\n        if (inner.to - inner.spaceAfter.length > pos - line.from)\r\n            return dont = { range };\r\n        let emptyLine = pos >= (inner.to - inner.spaceAfter.length) && !/\\S/.test(line.text.slice(inner.to));\r\n        // Empty line in list\r\n        if (inner.item && emptyLine) {\r\n            let first = inner.node.firstChild, second = inner.node.getChild(\"ListItem\", \"ListItem\");\r\n            // Not second item or blank line before: delete a level of markup\r\n            if (first.to >= pos || second && second.to < pos ||\r\n                line.from > 0 && !/[^\\s>]/.test(doc.lineAt(line.from - 1).text)) {\r\n                let next = context.length > 1 ? context[context.length - 2] : null;\r\n                let delTo, insert = \"\";\r\n                if (next && next.item) { // Re-add marker for the list at the next level\r\n                    delTo = line.from + next.from;\r\n                    insert = next.marker(doc, 1);\r\n                }\r\n                else {\r\n                    delTo = line.from + (next ? next.to : 0);\r\n                }\r\n                let changes = [{ from: delTo, to: pos, insert }];\r\n                if (inner.node.name == \"OrderedList\")\r\n                    renumberList(inner.item, doc, changes, -2);\r\n                if (next && next.node.name == \"OrderedList\")\r\n                    renumberList(next.item, doc, changes);\r\n                return { range: EditorSelection.cursor(delTo + insert.length), changes };\r\n            }\r\n            else { // Move second item down, making tight two-item list non-tight\r\n                let insert = blankLine(context, state, line);\r\n                return { range: EditorSelection.cursor(pos + insert.length + 1),\r\n                    changes: { from: line.from, insert: insert + state.lineBreak } };\r\n            }\r\n        }\r\n        if (inner.node.name == \"Blockquote\" && emptyLine && line.from) {\r\n            let prevLine = doc.lineAt(line.from - 1), quoted = />\\s*$/.exec(prevLine.text);\r\n            // Two aligned empty quoted lines in a row\r\n            if (quoted && quoted.index == inner.from) {\r\n                let changes = state.changes([{ from: prevLine.from + quoted.index, to: prevLine.to },\r\n                    { from: line.from + inner.from, to: line.to }]);\r\n                return { range: range.map(changes), changes };\r\n            }\r\n        }\r\n        let changes = [];\r\n        if (inner.node.name == \"OrderedList\")\r\n            renumberList(inner.item, doc, changes);\r\n        let continued = inner.item && inner.item.from < line.from;\r\n        let insert = \"\";\r\n        // If not dedented\r\n        if (!continued || /^[\\s\\d.)\\-+*>]*/.exec(line.text)[0].length >= inner.to) {\r\n            for (let i = 0, e = context.length - 1; i <= e; i++) {\r\n                insert += i == e && !continued ? context[i].marker(doc, 1)\r\n                    : context[i].blank(i < e ? countColumn(line.text, 4, context[i + 1].from) - insert.length : null);\r\n            }\r\n        }\r\n        let from = pos;\r\n        while (from > line.from && /\\s/.test(line.text.charAt(from - line.from - 1)))\r\n            from--;\r\n        insert = normalizeIndent(insert, state);\r\n        if (nonTightList(inner.node, state.doc))\r\n            insert = blankLine(context, state, line) + state.lineBreak + insert;\r\n        changes.push({ from, to: pos, insert: state.lineBreak + insert });\r\n        return { range: EditorSelection.cursor(from + insert.length + 1), changes };\r\n    });\r\n    if (dont)\r\n        return false;\r\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\r\n    return true;\r\n};\r\nfunction isMark(node) {\r\n    return node.name == \"QuoteMark\" || node.name == \"ListMark\";\r\n}\r\nfunction nonTightList(node, doc) {\r\n    if (node.name != \"OrderedList\" && node.name != \"BulletList\")\r\n        return false;\r\n    let first = node.firstChild, second = node.getChild(\"ListItem\", \"ListItem\");\r\n    if (!second)\r\n        return false;\r\n    let line1 = doc.lineAt(first.to), line2 = doc.lineAt(second.from);\r\n    let empty = /^[\\s>]*$/.test(line1.text);\r\n    return line1.number + (empty ? 0 : 1) < line2.number;\r\n}\r\nfunction blankLine(context, state, line) {\r\n    let insert = \"\";\r\n    for (let i = 0, e = context.length - 2; i <= e; i++) {\r\n        insert += context[i].blank(i < e ? countColumn(line.text, 4, context[i + 1].from) - insert.length : null, i < e);\r\n    }\r\n    return normalizeIndent(insert, state);\r\n}\r\nfunction contextNodeForDelete(tree, pos) {\r\n    let node = tree.resolveInner(pos, -1), scan = pos;\r\n    if (isMark(node)) {\r\n        scan = node.from;\r\n        node = node.parent;\r\n    }\r\n    for (let prev; prev = node.childBefore(scan);) {\r\n        if (isMark(prev)) {\r\n            scan = prev.from;\r\n        }\r\n        else if (prev.name == \"OrderedList\" || prev.name == \"BulletList\") {\r\n            node = prev.lastChild;\r\n            scan = node.to;\r\n        }\r\n        else {\r\n            break;\r\n        }\r\n    }\r\n    return node;\r\n}\r\n/**\r\nThis command will, when invoked in a Markdown context with the\r\ncursor directly after list or blockquote markup, delete one level\r\nof markup. When the markup is for a list, it will be replaced by\r\nspaces on the first invocation (a further invocation will delete\r\nthe spaces), to make it easy to continue a list.\r\n\r\nWhen not after Markdown block markup, this command will return\r\nfalse, so it is intended to be bound alongside other deletion\r\ncommands, with a higher precedence than the more generic commands.\r\n*/\r\nconst deleteMarkupBackward = ({ state, dispatch }) => {\r\n    let tree = syntaxTree(state);\r\n    let dont = null, changes = state.changeByRange(range => {\r\n        let pos = range.from, { doc } = state;\r\n        if (range.empty && markdownLanguage.isActiveAt(state, range.from)) {\r\n            let line = doc.lineAt(pos);\r\n            let context = getContext(contextNodeForDelete(tree, pos), doc);\r\n            if (context.length) {\r\n                let inner = context[context.length - 1];\r\n                let spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0);\r\n                // Delete extra trailing space after markup\r\n                if (pos - line.from > spaceEnd && !/\\S/.test(line.text.slice(spaceEnd, pos - line.from)))\r\n                    return { range: EditorSelection.cursor(line.from + spaceEnd),\r\n                        changes: { from: line.from + spaceEnd, to: pos } };\r\n                if (pos - line.from == spaceEnd &&\r\n                    // Only apply this if we're on the line that has the\r\n                    // construct's syntax, or there's only indentation in the\r\n                    // target range\r\n                    (!inner.item || line.from <= inner.item.from || !/\\S/.test(line.text.slice(0, inner.to)))) {\r\n                    let start = line.from + inner.from;\r\n                    // Replace a list item marker with blank space\r\n                    if (inner.item && inner.node.from < inner.item.from && /\\S/.test(line.text.slice(inner.from, inner.to))) {\r\n                        let insert = inner.blank(countColumn(line.text, 4, inner.to) - countColumn(line.text, 4, inner.from));\r\n                        if (start == line.from)\r\n                            insert = normalizeIndent(insert, state);\r\n                        return { range: EditorSelection.cursor(start + insert.length),\r\n                            changes: { from: start, to: line.from + inner.to, insert } };\r\n                    }\r\n                    // Delete one level of indentation\r\n                    if (start < pos)\r\n                        return { range: EditorSelection.cursor(start), changes: { from: start, to: pos } };\r\n                }\r\n            }\r\n        }\r\n        return dont = { range };\r\n    });\r\n    if (dont)\r\n        return false;\r\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"delete\" }));\r\n    return true;\r\n};\r\n\r\n/**\r\nA small keymap with Markdown-specific bindings. Binds Enter to\r\n[`insertNewlineContinueMarkup`](https://codemirror.net/6/docs/ref/#lang-markdown.insertNewlineContinueMarkup)\r\nand Backspace to\r\n[`deleteMarkupBackward`](https://codemirror.net/6/docs/ref/#lang-markdown.deleteMarkupBackward).\r\n*/\r\nconst markdownKeymap = [\r\n    { key: \"Enter\", run: insertNewlineContinueMarkup },\r\n    { key: \"Backspace\", run: deleteMarkupBackward }\r\n];\r\nconst htmlNoMatch = /*@__PURE__*/html({ matchClosingTags: false });\r\n/**\r\nMarkdown language support.\r\n*/\r\nfunction markdown(config = {}) {\r\n    let { codeLanguages, defaultCodeLanguage, addKeymap = true, base: { parser } = commonmarkLanguage, completeHTMLTags = true } = config;\r\n    if (!(parser instanceof MarkdownParser))\r\n        throw new RangeError(\"Base parser provided to `markdown` should be a Markdown parser\");\r\n    let extensions = config.extensions ? [config.extensions] : [];\r\n    let support = [htmlNoMatch.support], defaultCode;\r\n    if (defaultCodeLanguage instanceof LanguageSupport) {\r\n        support.push(defaultCodeLanguage.support);\r\n        defaultCode = defaultCodeLanguage.language;\r\n    }\r\n    else if (defaultCodeLanguage) {\r\n        defaultCode = defaultCodeLanguage;\r\n    }\r\n    let codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages, defaultCode) : undefined;\r\n    extensions.push(parseCode({ codeParser, htmlParser: htmlNoMatch.language.parser }));\r\n    if (addKeymap)\r\n        support.push(Prec.high(keymap.of(markdownKeymap)));\r\n    let lang = mkLang(parser.configure(extensions));\r\n    if (completeHTMLTags)\r\n        support.push(lang.data.of({ autocomplete: htmlTagCompletion }));\r\n    return new LanguageSupport(lang, support);\r\n}\r\nfunction htmlTagCompletion(context) {\r\n    let { state, pos } = context, m = /<[:\\-\\.\\w\\u00b7-\\uffff]*$/.exec(state.sliceDoc(pos - 25, pos));\r\n    if (!m)\r\n        return null;\r\n    let tree = syntaxTree(state).resolveInner(pos, -1);\r\n    while (tree && !tree.type.isTop) {\r\n        if (tree.name == \"CodeBlock\" || tree.name == \"FencedCode\" || tree.name == \"ProcessingInstructionBlock\" ||\r\n            tree.name == \"CommentBlock\" || tree.name == \"Link\" || tree.name == \"Image\")\r\n            return null;\r\n        tree = tree.parent;\r\n    }\r\n    return {\r\n        from: pos - m[0].length, to: pos,\r\n        options: htmlTagCompletions(),\r\n        validFor: /^<[:\\-\\.\\w\\u00b7-\\uffff]*$/\r\n    };\r\n}\r\nlet _tagCompletions = null;\r\nfunction htmlTagCompletions() {\r\n    if (_tagCompletions)\r\n        return _tagCompletions;\r\n    let result = htmlCompletionSource(new CompletionContext(EditorState.create({ extensions: htmlNoMatch }), 0, true));\r\n    return _tagCompletions = result ? result.options : [];\r\n}\r\n\r\nexport { commonmarkLanguage, deleteMarkupBackward, insertNewlineContinueMarkup, markdown, markdownKeymap, markdownLanguage };\r\n"],
  "mappings": "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",
  "names": ["Type", "elt", "count", "parser", "nodeTypes", "spec", "node", "m", "next", "parser", "node", "space", "insert", "changes"]
}
