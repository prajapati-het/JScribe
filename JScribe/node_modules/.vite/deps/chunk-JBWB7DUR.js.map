{
  "version": 3,
  "sources": ["../../@codemirror/legacy-modes/mode/xquery.js"],
  "sourcesContent": ["// The keywords object is set to the result of this self executing\r\n// function. Each keyword is a property of the keywords object whose\r\n// value is {type: atype, style: astyle}\r\nvar keywords = function(){\r\n  // convenience functions used to build keywords object\r\n  function kw(type) {return {type: type, style: \"keyword\"};}\r\n  var operator = kw(\"operator\")\r\n  , atom = {type: \"atom\", style: \"atom\"}\r\n  , punctuation = {type: \"punctuation\", style: null}\r\n  , qualifier = {type: \"axis_specifier\", style: \"qualifier\"};\r\n\r\n  // kwObj is what is return from this function at the end\r\n  var kwObj = {\r\n    ',': punctuation\r\n  };\r\n\r\n  // a list of 'basic' keywords. For each add a property to kwObj with the value of\r\n  // {type: basic[i], style: \"keyword\"} e.g. 'after' --> {type: \"after\", style: \"keyword\"}\r\n  var basic = ['after', 'all', 'allowing', 'ancestor', 'ancestor-or-self', 'any', 'array', 'as',\r\n               'ascending', 'at', 'attribute', 'base-uri', 'before', 'boundary-space', 'by', 'case', 'cast',\r\n               'castable', 'catch', 'child', 'collation', 'comment', 'construction', 'contains', 'content',\r\n               'context', 'copy', 'copy-namespaces', 'count', 'decimal-format', 'declare', 'default', 'delete',\r\n               'descendant', 'descendant-or-self', 'descending', 'diacritics', 'different', 'distance',\r\n               'document', 'document-node', 'element', 'else', 'empty', 'empty-sequence', 'encoding', 'end',\r\n               'entire', 'every', 'exactly', 'except', 'external', 'first', 'following', 'following-sibling',\r\n               'for', 'from', 'ftand', 'ftnot', 'ft-option', 'ftor', 'function', 'fuzzy', 'greatest', 'group',\r\n               'if', 'import', 'in', 'inherit', 'insensitive', 'insert', 'instance', 'intersect', 'into',\r\n               'invoke', 'is', 'item', 'language', 'last', 'lax', 'least', 'let', 'levels', 'lowercase', 'map',\r\n               'modify', 'module', 'most', 'namespace', 'next', 'no', 'node', 'nodes', 'no-inherit',\r\n               'no-preserve', 'not', 'occurs', 'of', 'only', 'option', 'order', 'ordered', 'ordering',\r\n               'paragraph', 'paragraphs', 'parent', 'phrase', 'preceding', 'preceding-sibling', 'preserve',\r\n               'previous', 'processing-instruction', 'relationship', 'rename', 'replace', 'return',\r\n               'revalidation', 'same', 'satisfies', 'schema', 'schema-attribute', 'schema-element', 'score',\r\n               'self', 'sensitive', 'sentence', 'sentences', 'sequence', 'skip', 'sliding', 'some', 'stable',\r\n               'start', 'stemming', 'stop', 'strict', 'strip', 'switch', 'text', 'then', 'thesaurus', 'times',\r\n               'to', 'transform', 'treat', 'try', 'tumbling', 'type', 'typeswitch', 'union', 'unordered',\r\n               'update', 'updating', 'uppercase', 'using', 'validate', 'value', 'variable', 'version',\r\n               'weight', 'when', 'where', 'wildcards', 'window', 'with', 'without', 'word', 'words', 'xquery'];\r\n  for(var i=0, l=basic.length; i < l; i++) { kwObj[basic[i]] = kw(basic[i]);};\r\n\r\n  // a list of types. For each add a property to kwObj with the value of\r\n  // {type: \"atom\", style: \"atom\"}\r\n  var types = ['xs:anyAtomicType', 'xs:anySimpleType', 'xs:anyType', 'xs:anyURI',\r\n               'xs:base64Binary', 'xs:boolean', 'xs:byte', 'xs:date', 'xs:dateTime', 'xs:dateTimeStamp',\r\n               'xs:dayTimeDuration', 'xs:decimal', 'xs:double', 'xs:duration', 'xs:ENTITIES', 'xs:ENTITY',\r\n               'xs:float', 'xs:gDay', 'xs:gMonth', 'xs:gMonthDay', 'xs:gYear', 'xs:gYearMonth', 'xs:hexBinary',\r\n               'xs:ID', 'xs:IDREF', 'xs:IDREFS', 'xs:int', 'xs:integer', 'xs:item', 'xs:java', 'xs:language',\r\n               'xs:long', 'xs:Name', 'xs:NCName', 'xs:negativeInteger', 'xs:NMTOKEN', 'xs:NMTOKENS',\r\n               'xs:nonNegativeInteger', 'xs:nonPositiveInteger', 'xs:normalizedString', 'xs:NOTATION',\r\n               'xs:numeric', 'xs:positiveInteger', 'xs:precisionDecimal', 'xs:QName', 'xs:short', 'xs:string',\r\n               'xs:time', 'xs:token', 'xs:unsignedByte', 'xs:unsignedInt', 'xs:unsignedLong',\r\n               'xs:unsignedShort', 'xs:untyped', 'xs:untypedAtomic', 'xs:yearMonthDuration'];\r\n  for(var i=0, l=types.length; i < l; i++) { kwObj[types[i]] = atom;};\r\n\r\n  // each operator will add a property to kwObj with value of {type: \"operator\", style: \"keyword\"}\r\n  var operators = ['eq', 'ne', 'lt', 'le', 'gt', 'ge', ':=', '=', '>', '>=', '<', '<=', '.', '|', '?', 'and', 'or', 'div', 'idiv', 'mod', '*', '/', '+', '-'];\r\n  for(var i=0, l=operators.length; i < l; i++) { kwObj[operators[i]] = operator;};\r\n\r\n  // each axis_specifiers will add a property to kwObj with value of {type: \"axis_specifier\", style: \"qualifier\"}\r\n  var axis_specifiers = [\"self::\", \"attribute::\", \"child::\", \"descendant::\", \"descendant-or-self::\", \"parent::\",\r\n                         \"ancestor::\", \"ancestor-or-self::\", \"following::\", \"preceding::\", \"following-sibling::\", \"preceding-sibling::\"];\r\n  for(var i=0, l=axis_specifiers.length; i < l; i++) { kwObj[axis_specifiers[i]] = qualifier; };\r\n\r\n  return kwObj;\r\n}();\r\n\r\nfunction chain(stream, state, f) {\r\n  state.tokenize = f;\r\n  return f(stream, state);\r\n}\r\n\r\n// the primary mode tokenizer\r\nfunction tokenBase(stream, state) {\r\n  var ch = stream.next(),\r\n      mightBeFunction = false,\r\n      isEQName = isEQNameAhead(stream);\r\n\r\n  // an XML tag (if not in some sub, chained tokenizer)\r\n  if (ch == \"<\") {\r\n    if(stream.match(\"!--\", true))\r\n      return chain(stream, state, tokenXMLComment);\r\n\r\n    if(stream.match(\"![CDATA\", false)) {\r\n      state.tokenize = tokenCDATA;\r\n      return \"tag\";\r\n    }\r\n\r\n    if(stream.match(\"?\", false)) {\r\n      return chain(stream, state, tokenPreProcessing);\r\n    }\r\n\r\n    var isclose = stream.eat(\"/\");\r\n    stream.eatSpace();\r\n    var tagName = \"\", c;\r\n    while ((c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/))) tagName += c;\r\n\r\n    return chain(stream, state, tokenTag(tagName, isclose));\r\n  }\r\n  // start code block\r\n  else if(ch == \"{\") {\r\n    pushStateStack(state, { type: \"codeblock\"});\r\n    return null;\r\n  }\r\n  // end code block\r\n  else if(ch == \"}\") {\r\n    popStateStack(state);\r\n    return null;\r\n  }\r\n  // if we're in an XML block\r\n  else if(isInXmlBlock(state)) {\r\n    if(ch == \">\")\r\n      return \"tag\";\r\n    else if(ch == \"/\" && stream.eat(\">\")) {\r\n      popStateStack(state);\r\n      return \"tag\";\r\n    }\r\n    else\r\n      return \"variable\";\r\n  }\r\n  // if a number\r\n  else if (/\\d/.test(ch)) {\r\n    stream.match(/^\\d*(?:\\.\\d*)?(?:E[+\\-]?\\d+)?/);\r\n    return \"atom\";\r\n  }\r\n  // comment start\r\n  else if (ch === \"(\" && stream.eat(\":\")) {\r\n    pushStateStack(state, { type: \"comment\"});\r\n    return chain(stream, state, tokenComment);\r\n  }\r\n  // quoted string\r\n  else if (!isEQName && (ch === '\"' || ch === \"'\"))\r\n    return chain(stream, state, tokenString(ch));\r\n  // variable\r\n  else if(ch === \"$\") {\r\n    return chain(stream, state, tokenVariable);\r\n  }\r\n  // assignment\r\n  else if(ch ===\":\" && stream.eat(\"=\")) {\r\n    return \"keyword\";\r\n  }\r\n  // open paren\r\n  else if(ch === \"(\") {\r\n    pushStateStack(state, { type: \"paren\"});\r\n    return null;\r\n  }\r\n  // close paren\r\n  else if(ch === \")\") {\r\n    popStateStack(state);\r\n    return null;\r\n  }\r\n  // open paren\r\n  else if(ch === \"[\") {\r\n    pushStateStack(state, { type: \"bracket\"});\r\n    return null;\r\n  }\r\n  // close paren\r\n  else if(ch === \"]\") {\r\n    popStateStack(state);\r\n    return null;\r\n  }\r\n  else {\r\n    var known = keywords.propertyIsEnumerable(ch) && keywords[ch];\r\n\r\n    // if there's a EQName ahead, consume the rest of the string portion, it's likely a function\r\n    if(isEQName && ch === '\\\"') while(stream.next() !== '\"'){}\r\n    if(isEQName && ch === '\\'') while(stream.next() !== '\\''){}\r\n\r\n    // gobble up a word if the character is not known\r\n    if(!known) stream.eatWhile(/[\\w\\$_-]/);\r\n\r\n    // gobble a colon in the case that is a lib func type call fn:doc\r\n    var foundColon = stream.eat(\":\");\r\n\r\n    // if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier\r\n    // which should get matched as a keyword\r\n    if(!stream.eat(\":\") && foundColon) {\r\n      stream.eatWhile(/[\\w\\$_-]/);\r\n    }\r\n    // if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)\r\n    if(stream.match(/^[ \\t]*\\(/, false)) {\r\n      mightBeFunction = true;\r\n    }\r\n    // is the word a keyword?\r\n    var word = stream.current();\r\n    known = keywords.propertyIsEnumerable(word) && keywords[word];\r\n\r\n    // if we think it's a function call but not yet known,\r\n    // set style to variable for now for lack of something better\r\n    if(mightBeFunction && !known) known = {type: \"function_call\", style: \"def\"};\r\n\r\n    // if the previous word was element, attribute, axis specifier, this word should be the name of that\r\n    if(isInXmlConstructor(state)) {\r\n      popStateStack(state);\r\n      return \"variable\";\r\n    }\r\n    // as previously checked, if the word is element,attribute, axis specifier, call it an \"xmlconstructor\" and\r\n    // push the stack so we know to look for it on the next word\r\n    if(word == \"element\" || word == \"attribute\" || known.type == \"axis_specifier\") pushStateStack(state, {type: \"xmlconstructor\"});\r\n\r\n    // if the word is known, return the details of that else just call this a generic 'word'\r\n    return known ? known.style : \"variable\";\r\n  }\r\n}\r\n\r\n// handle comments, including nested\r\nfunction tokenComment(stream, state) {\r\n  var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;\r\n  while (ch = stream.next()) {\r\n    if (ch == \")\" && maybeEnd) {\r\n      if(nestedCount > 0)\r\n        nestedCount--;\r\n      else {\r\n        popStateStack(state);\r\n        break;\r\n      }\r\n    }\r\n    else if(ch == \":\" && maybeNested) {\r\n      nestedCount++;\r\n    }\r\n    maybeEnd = (ch == \":\");\r\n    maybeNested = (ch == \"(\");\r\n  }\r\n\r\n  return \"comment\";\r\n}\r\n\r\n// tokenizer for string literals\r\n// optionally pass a tokenizer function to set state.tokenize back to when finished\r\nfunction tokenString(quote, f) {\r\n  return function(stream, state) {\r\n    var ch;\r\n\r\n    if(isInString(state) && stream.current() == quote) {\r\n      popStateStack(state);\r\n      if(f) state.tokenize = f;\r\n      return \"string\";\r\n    }\r\n\r\n    pushStateStack(state, { type: \"string\", name: quote, tokenize: tokenString(quote, f) });\r\n\r\n    // if we're in a string and in an XML block, allow an embedded code block\r\n    if(stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\r\n      state.tokenize = tokenBase;\r\n      return \"string\";\r\n    }\r\n\r\n\r\n    while (ch = stream.next()) {\r\n      if (ch ==  quote) {\r\n        popStateStack(state);\r\n        if(f) state.tokenize = f;\r\n        break;\r\n      }\r\n      else {\r\n        // if we're in a string and in an XML block, allow an embedded code block in an attribute\r\n        if(stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\r\n          state.tokenize = tokenBase;\r\n          return \"string\";\r\n        }\r\n\r\n      }\r\n    }\r\n\r\n    return \"string\";\r\n  };\r\n}\r\n\r\n// tokenizer for variables\r\nfunction tokenVariable(stream, state) {\r\n  var isVariableChar = /[\\w\\$_-]/;\r\n\r\n  // a variable may start with a quoted EQName so if the next character is quote, consume to the next quote\r\n  if(stream.eat(\"\\\"\")) {\r\n    while(stream.next() !== '\\\"'){};\r\n    stream.eat(\":\");\r\n  } else {\r\n    stream.eatWhile(isVariableChar);\r\n    if(!stream.match(\":=\", false)) stream.eat(\":\");\r\n  }\r\n  stream.eatWhile(isVariableChar);\r\n  state.tokenize = tokenBase;\r\n  return \"variable\";\r\n}\r\n\r\n// tokenizer for XML tags\r\nfunction tokenTag(name, isclose) {\r\n  return function(stream, state) {\r\n    stream.eatSpace();\r\n    if(isclose && stream.eat(\">\")) {\r\n      popStateStack(state);\r\n      state.tokenize = tokenBase;\r\n      return \"tag\";\r\n    }\r\n    // self closing tag without attributes?\r\n    if(!stream.eat(\"/\"))\r\n      pushStateStack(state, { type: \"tag\", name: name, tokenize: tokenBase});\r\n    if(!stream.eat(\">\")) {\r\n      state.tokenize = tokenAttribute;\r\n      return \"tag\";\r\n    }\r\n    else {\r\n      state.tokenize = tokenBase;\r\n    }\r\n    return \"tag\";\r\n  };\r\n}\r\n\r\n// tokenizer for XML attributes\r\nfunction tokenAttribute(stream, state) {\r\n  var ch = stream.next();\r\n\r\n  if(ch == \"/\" && stream.eat(\">\")) {\r\n    if(isInXmlAttributeBlock(state)) popStateStack(state);\r\n    if(isInXmlBlock(state)) popStateStack(state);\r\n    return \"tag\";\r\n  }\r\n  if(ch == \">\") {\r\n    if(isInXmlAttributeBlock(state)) popStateStack(state);\r\n    return \"tag\";\r\n  }\r\n  if(ch == \"=\")\r\n    return null;\r\n  // quoted string\r\n  if (ch == '\"' || ch == \"'\")\r\n    return chain(stream, state, tokenString(ch, tokenAttribute));\r\n\r\n  if(!isInXmlAttributeBlock(state))\r\n    pushStateStack(state, { type: \"attribute\", tokenize: tokenAttribute});\r\n\r\n  stream.eat(/[a-zA-Z_:]/);\r\n  stream.eatWhile(/[-a-zA-Z0-9_:.]/);\r\n  stream.eatSpace();\r\n\r\n  // the case where the attribute has not value and the tag was closed\r\n  if(stream.match(\">\", false) || stream.match(\"/\", false)) {\r\n    popStateStack(state);\r\n    state.tokenize = tokenBase;\r\n  }\r\n\r\n  return \"attribute\";\r\n}\r\n\r\n// handle comments, including nested\r\nfunction tokenXMLComment(stream, state) {\r\n  var ch;\r\n  while (ch = stream.next()) {\r\n    if (ch == \"-\" && stream.match(\"->\", true)) {\r\n      state.tokenize = tokenBase;\r\n      return \"comment\";\r\n    }\r\n  }\r\n}\r\n\r\n\r\n// handle CDATA\r\nfunction tokenCDATA(stream, state) {\r\n  var ch;\r\n  while (ch = stream.next()) {\r\n    if (ch == \"]\" && stream.match(\"]\", true)) {\r\n      state.tokenize = tokenBase;\r\n      return \"comment\";\r\n    }\r\n  }\r\n}\r\n\r\n// handle preprocessing instructions\r\nfunction tokenPreProcessing(stream, state) {\r\n  var ch;\r\n  while (ch = stream.next()) {\r\n    if (ch == \"?\" && stream.match(\">\", true)) {\r\n      state.tokenize = tokenBase;\r\n      return \"processingInstruction\";\r\n    }\r\n  }\r\n}\r\n\r\n\r\n// functions to test the current context of the state\r\nfunction isInXmlBlock(state) { return isIn(state, \"tag\"); }\r\nfunction isInXmlAttributeBlock(state) { return isIn(state, \"attribute\"); }\r\nfunction isInXmlConstructor(state) { return isIn(state, \"xmlconstructor\"); }\r\nfunction isInString(state) { return isIn(state, \"string\"); }\r\n\r\nfunction isEQNameAhead(stream) {\r\n  // assume we've already eaten a quote (\")\r\n  if(stream.current() === '\"')\r\n    return stream.match(/^[^\\\"]+\\\"\\:/, false);\r\n  else if(stream.current() === '\\'')\r\n    return stream.match(/^[^\\\"]+\\'\\:/, false);\r\n  else\r\n    return false;\r\n}\r\n\r\nfunction isIn(state, type) {\r\n  return (state.stack.length && state.stack[state.stack.length - 1].type == type);\r\n}\r\n\r\nfunction pushStateStack(state, newState) {\r\n  state.stack.push(newState);\r\n}\r\n\r\nfunction popStateStack(state) {\r\n  state.stack.pop();\r\n  var reinstateTokenize = state.stack.length && state.stack[state.stack.length-1].tokenize;\r\n  state.tokenize = reinstateTokenize || tokenBase;\r\n}\r\n\r\n// the interface for the mode API\r\nexport const xQuery = {\r\n  name: \"xquery\",\r\n  startState: function() {\r\n    return {\r\n      tokenize: tokenBase,\r\n      cc: [],\r\n      stack: []\r\n    };\r\n  },\r\n\r\n  token: function(stream, state) {\r\n    if (stream.eatSpace()) return null;\r\n    var style = state.tokenize(stream, state);\r\n    return style;\r\n  },\r\n\r\n  languageData: {\r\n    commentTokens: {block: {open: \"(:\", close: \":)\"}}\r\n  }\r\n};\r\n"],
  "mappings": "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",
  "names": []
}
