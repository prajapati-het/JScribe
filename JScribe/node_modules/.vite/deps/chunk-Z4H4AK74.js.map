{
  "version": 3,
  "sources": ["../../@codemirror/legacy-modes/mode/verilog.js"],
  "sourcesContent": ["function mkVerilog(parserConfig) {\r\n\r\n  var statementIndentUnit = parserConfig.statementIndentUnit,\r\n      dontAlignCalls = parserConfig.dontAlignCalls,\r\n      noIndentKeywords = parserConfig.noIndentKeywords || [],\r\n      multiLineStrings = parserConfig.multiLineStrings,\r\n      hooks = parserConfig.hooks || {};\r\n\r\n  function words(str) {\r\n    var obj = {}, words = str.split(\" \");\r\n    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\r\n    return obj;\r\n  }\r\n\r\n  /**\r\n   * Keywords from IEEE 1800-2012\r\n   */\r\n  var keywords = words(\r\n    \"accept_on alias always always_comb always_ff always_latch and assert assign assume automatic before begin bind \" +\r\n      \"bins binsof bit break buf bufif0 bufif1 byte case casex casez cell chandle checker class clocking cmos config \" +\r\n      \"const constraint context continue cover covergroup coverpoint cross deassign default defparam design disable \" +\r\n      \"dist do edge else end endcase endchecker endclass endclocking endconfig endfunction endgenerate endgroup \" +\r\n      \"endinterface endmodule endpackage endprimitive endprogram endproperty endspecify endsequence endtable endtask \" +\r\n      \"enum event eventually expect export extends extern final first_match for force foreach forever fork forkjoin \" +\r\n      \"function generate genvar global highz0 highz1 if iff ifnone ignore_bins illegal_bins implements implies import \" +\r\n      \"incdir include initial inout input inside instance int integer interconnect interface intersect join join_any \" +\r\n      \"join_none large let liblist library local localparam logic longint macromodule matches medium modport module \" +\r\n      \"nand negedge nettype new nexttime nmos nor noshowcancelled not notif0 notif1 null or output package packed \" +\r\n      \"parameter pmos posedge primitive priority program property protected pull0 pull1 pulldown pullup \" +\r\n      \"pulsestyle_ondetect pulsestyle_onevent pure rand randc randcase randsequence rcmos real realtime ref reg \" +\r\n      \"reject_on release repeat restrict return rnmos rpmos rtran rtranif0 rtranif1 s_always s_eventually s_nexttime \" +\r\n      \"s_until s_until_with scalared sequence shortint shortreal showcancelled signed small soft solve specify \" +\r\n      \"specparam static string strong strong0 strong1 struct super supply0 supply1 sync_accept_on sync_reject_on \" +\r\n      \"table tagged task this throughout time timeprecision timeunit tran tranif0 tranif1 tri tri0 tri1 triand trior \" +\r\n      \"trireg type typedef union unique unique0 unsigned until until_with untyped use uwire var vectored virtual void \" +\r\n      \"wait wait_order wand weak weak0 weak1 while wildcard wire with within wor xnor xor\");\r\n\r\n  /** Operators from IEEE 1800-2012\r\n      unary_operator ::=\r\n      + | - | ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\r\n      binary_operator ::=\r\n      + | - | * | / | % | == | != | === | !== | ==? | !=? | && | || | **\r\n      | < | <= | > | >= | & | | | ^ | ^~ | ~^ | >> | << | >>> | <<<\r\n      | -> | <->\r\n      inc_or_dec_operator ::= ++ | --\r\n      unary_module_path_operator ::=\r\n      ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\r\n      binary_module_path_operator ::=\r\n      == | != | && | || | & | | | ^ | ^~ | ~^\r\n  */\r\n  var isOperatorChar = /[\\+\\-\\*\\/!~&|^%=?:]/;\r\n  var isBracketChar = /[\\[\\]{}()]/;\r\n\r\n  var unsignedNumber = /\\d[0-9_]*/;\r\n  var decimalLiteral = /\\d*\\s*'s?d\\s*\\d[0-9_]*/i;\r\n  var binaryLiteral = /\\d*\\s*'s?b\\s*[xz01][xz01_]*/i;\r\n  var octLiteral = /\\d*\\s*'s?o\\s*[xz0-7][xz0-7_]*/i;\r\n  var hexLiteral = /\\d*\\s*'s?h\\s*[0-9a-fxz?][0-9a-fxz?_]*/i;\r\n  var realLiteral = /(\\d[\\d_]*(\\.\\d[\\d_]*)?E-?[\\d_]+)|(\\d[\\d_]*\\.\\d[\\d_]*)/i;\r\n\r\n  var closingBracketOrWord = /^((\\w+)|[)}\\]])/;\r\n  var closingBracket = /[)}\\]]/;\r\n\r\n  var curPunc;\r\n  var curKeyword;\r\n\r\n  // Block openings which are closed by a matching keyword in the form of (\"end\" + keyword)\r\n  // E.g. \"task\" => \"endtask\"\r\n  var blockKeywords = words(\r\n    \"case checker class clocking config function generate interface module package \" +\r\n      \"primitive program property specify sequence table task\"\r\n  );\r\n\r\n  // Opening/closing pairs\r\n  var openClose = {};\r\n  for (var keyword in blockKeywords) {\r\n    openClose[keyword] = \"end\" + keyword;\r\n  }\r\n  openClose[\"begin\"] = \"end\";\r\n  openClose[\"casex\"] = \"endcase\";\r\n  openClose[\"casez\"] = \"endcase\";\r\n  openClose[\"do\"   ] = \"while\";\r\n  openClose[\"fork\" ] = \"join;join_any;join_none\";\r\n  openClose[\"covergroup\"] = \"endgroup\";\r\n\r\n  for (var i in noIndentKeywords) {\r\n    var keyword = noIndentKeywords[i];\r\n    if (openClose[keyword]) {\r\n      openClose[keyword] = undefined;\r\n    }\r\n  }\r\n\r\n  // Keywords which open statements that are ended with a semi-colon\r\n  var statementKeywords = words(\"always always_comb always_ff always_latch assert assign assume else export for foreach forever if import initial repeat while\");\r\n\r\n  function tokenBase(stream, state) {\r\n    var ch = stream.peek(), style;\r\n    if (hooks[ch] && (style = hooks[ch](stream, state)) != false) return style;\r\n    if (hooks.tokenBase && (style = hooks.tokenBase(stream, state)) != false)\r\n      return style;\r\n\r\n    if (/[,;:\\.]/.test(ch)) {\r\n      curPunc = stream.next();\r\n      return null;\r\n    }\r\n    if (isBracketChar.test(ch)) {\r\n      curPunc = stream.next();\r\n      return \"bracket\";\r\n    }\r\n    // Macros (tick-defines)\r\n    if (ch == '`') {\r\n      stream.next();\r\n      if (stream.eatWhile(/[\\w\\$_]/)) {\r\n        return \"def\";\r\n      } else {\r\n        return null;\r\n      }\r\n    }\r\n    // System calls\r\n    if (ch == '$') {\r\n      stream.next();\r\n      if (stream.eatWhile(/[\\w\\$_]/)) {\r\n        return \"meta\";\r\n      } else {\r\n        return null;\r\n      }\r\n    }\r\n    // Time literals\r\n    if (ch == '#') {\r\n      stream.next();\r\n      stream.eatWhile(/[\\d_.]/);\r\n      return \"def\";\r\n    }\r\n    // Strings\r\n    if (ch == '\"') {\r\n      stream.next();\r\n      state.tokenize = tokenString(ch);\r\n      return state.tokenize(stream, state);\r\n    }\r\n    // Comments\r\n    if (ch == \"/\") {\r\n      stream.next();\r\n      if (stream.eat(\"*\")) {\r\n        state.tokenize = tokenComment;\r\n        return tokenComment(stream, state);\r\n      }\r\n      if (stream.eat(\"/\")) {\r\n        stream.skipToEnd();\r\n        return \"comment\";\r\n      }\r\n      stream.backUp(1);\r\n    }\r\n\r\n    // Numeric literals\r\n    if (stream.match(realLiteral) ||\r\n        stream.match(decimalLiteral) ||\r\n        stream.match(binaryLiteral) ||\r\n        stream.match(octLiteral) ||\r\n        stream.match(hexLiteral) ||\r\n        stream.match(unsignedNumber) ||\r\n        stream.match(realLiteral)) {\r\n      return \"number\";\r\n    }\r\n\r\n    // Operators\r\n    if (stream.eatWhile(isOperatorChar)) {\r\n      return \"meta\";\r\n    }\r\n\r\n    // Keywords / plain variables\r\n    if (stream.eatWhile(/[\\w\\$_]/)) {\r\n      var cur = stream.current();\r\n      if (keywords[cur]) {\r\n        if (openClose[cur]) {\r\n          curPunc = \"newblock\";\r\n        }\r\n        if (statementKeywords[cur]) {\r\n          curPunc = \"newstatement\";\r\n        }\r\n        curKeyword = cur;\r\n        return \"keyword\";\r\n      }\r\n      return \"variable\";\r\n    }\r\n\r\n    stream.next();\r\n    return null;\r\n  }\r\n\r\n  function tokenString(quote) {\r\n    return function(stream, state) {\r\n      var escaped = false, next, end = false;\r\n      while ((next = stream.next()) != null) {\r\n        if (next == quote && !escaped) {end = true; break;}\r\n        escaped = !escaped && next == \"\\\\\";\r\n      }\r\n      if (end || !(escaped || multiLineStrings))\r\n        state.tokenize = tokenBase;\r\n      return \"string\";\r\n    };\r\n  }\r\n\r\n  function tokenComment(stream, state) {\r\n    var maybeEnd = false, ch;\r\n    while (ch = stream.next()) {\r\n      if (ch == \"/\" && maybeEnd) {\r\n        state.tokenize = tokenBase;\r\n        break;\r\n      }\r\n      maybeEnd = (ch == \"*\");\r\n    }\r\n    return \"comment\";\r\n  }\r\n\r\n  function Context(indented, column, type, align, prev) {\r\n    this.indented = indented;\r\n    this.column = column;\r\n    this.type = type;\r\n    this.align = align;\r\n    this.prev = prev;\r\n  }\r\n  function pushContext(state, col, type) {\r\n    var indent = state.indented;\r\n    var c = new Context(indent, col, type, null, state.context);\r\n    return state.context = c;\r\n  }\r\n  function popContext(state) {\r\n    var t = state.context.type;\r\n    if (t == \")\" || t == \"]\" || t == \"}\") {\r\n      state.indented = state.context.indented;\r\n    }\r\n    return state.context = state.context.prev;\r\n  }\r\n\r\n  function isClosing(text, contextClosing) {\r\n    if (text == contextClosing) {\r\n      return true;\r\n    } else {\r\n      // contextClosing may be multiple keywords separated by ;\r\n      var closingKeywords = contextClosing.split(\";\");\r\n      for (var i in closingKeywords) {\r\n        if (text == closingKeywords[i]) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n  }\r\n\r\n  function buildElectricInputRegEx() {\r\n    // Reindentation should occur on any bracket char: {}()[]\r\n    // or on a match of any of the block closing keywords, at\r\n    // the end of a line\r\n    var allClosings = [];\r\n    for (var i in openClose) {\r\n      if (openClose[i]) {\r\n        var closings = openClose[i].split(\";\");\r\n        for (var j in closings) {\r\n          allClosings.push(closings[j]);\r\n        }\r\n      }\r\n    }\r\n    var re = new RegExp(\"[{}()\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\r\n    return re;\r\n  }\r\n\r\n  // Interface\r\n  return {\r\n    name: \"verilog\",\r\n\r\n    startState: function(indentUnit) {\r\n      var state = {\r\n        tokenize: null,\r\n        context: new Context(-indentUnit, 0, \"top\", false),\r\n        indented: 0,\r\n        startOfLine: true\r\n      };\r\n      if (hooks.startState) hooks.startState(state);\r\n      return state;\r\n    },\r\n\r\n    token: function(stream, state) {\r\n      var ctx = state.context;\r\n      if (stream.sol()) {\r\n        if (ctx.align == null) ctx.align = false;\r\n        state.indented = stream.indentation();\r\n        state.startOfLine = true;\r\n      }\r\n      if (hooks.token) {\r\n        // Call hook, with an optional return value of a style to override verilog styling.\r\n        var style = hooks.token(stream, state);\r\n        if (style !== undefined) {\r\n          return style;\r\n        }\r\n      }\r\n      if (stream.eatSpace()) return null;\r\n      curPunc = null;\r\n      curKeyword = null;\r\n      var style = (state.tokenize || tokenBase)(stream, state);\r\n      if (style == \"comment\" || style == \"meta\" || style == \"variable\") return style;\r\n      if (ctx.align == null) ctx.align = true;\r\n\r\n      if (curPunc == ctx.type) {\r\n        popContext(state);\r\n      } else if ((curPunc == \";\" && ctx.type == \"statement\") ||\r\n                 (ctx.type && isClosing(curKeyword, ctx.type))) {\r\n        ctx = popContext(state);\r\n        while (ctx && ctx.type == \"statement\") ctx = popContext(state);\r\n      } else if (curPunc == \"{\") {\r\n        pushContext(state, stream.column(), \"}\");\r\n      } else if (curPunc == \"[\") {\r\n        pushContext(state, stream.column(), \"]\");\r\n      } else if (curPunc == \"(\") {\r\n        pushContext(state, stream.column(), \")\");\r\n      } else if (ctx && ctx.type == \"endcase\" && curPunc == \":\") {\r\n        pushContext(state, stream.column(), \"statement\");\r\n      } else if (curPunc == \"newstatement\") {\r\n        pushContext(state, stream.column(), \"statement\");\r\n      } else if (curPunc == \"newblock\") {\r\n        if (curKeyword == \"function\" && ctx && (ctx.type == \"statement\" || ctx.type == \"endgroup\")) {\r\n          // The 'function' keyword can appear in some other contexts where it actually does not\r\n          // indicate a function (import/export DPI and covergroup definitions).\r\n          // Do nothing in this case\r\n        } else if (curKeyword == \"task\" && ctx && ctx.type == \"statement\") {\r\n          // Same thing for task\r\n        } else {\r\n          var close = openClose[curKeyword];\r\n          pushContext(state, stream.column(), close);\r\n        }\r\n      }\r\n\r\n      state.startOfLine = false;\r\n      return style;\r\n    },\r\n\r\n    indent: function(state, textAfter, cx) {\r\n      if (state.tokenize != tokenBase && state.tokenize != null) return null;\r\n      if (hooks.indent) {\r\n        var fromHook = hooks.indent(state);\r\n        if (fromHook >= 0) return fromHook;\r\n      }\r\n      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);\r\n      if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\r\n      var closing = false;\r\n      var possibleClosing = textAfter.match(closingBracketOrWord);\r\n      if (possibleClosing)\r\n        closing = isClosing(possibleClosing[0], ctx.type);\r\n      if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : statementIndentUnit || cx.unit);\r\n      else if (closingBracket.test(ctx.type) && ctx.align && !dontAlignCalls) return ctx.column + (closing ? 0 : 1);\r\n      else if (ctx.type == \")\" && !closing) return ctx.indented + (statementIndentUnit || cx.unit);\r\n      else return ctx.indented + (closing ? 0 : cx.unit);\r\n    },\r\n\r\n    languageData: {\r\n      indentOnInput: buildElectricInputRegEx(),\r\n      commentTokens: {line: \"//\", block: {open: \"/*\", close: \"*/\"}}\r\n    }\r\n  };\r\n};\r\n\r\nexport const verilog = mkVerilog({})\r\n\r\n// TL-Verilog mode.\r\n// See tl-x.org for language spec.\r\n// See the mode in action at makerchip.com.\r\n// Contact: steve.hoover@redwoodeda.com\r\n\r\n// TLV Identifier prefixes.\r\n// Note that sign is not treated separately, so \"+/-\" versions of numeric identifiers\r\n// are included.\r\nvar tlvIdentifierStyle = {\r\n  \"|\": \"link\",\r\n  \">\": \"property\",  // Should condition this off for > TLV 1c.\r\n  \"$\": \"variable\",\r\n  \"$$\": \"variable\",\r\n  \"?$\": \"qualifier\",\r\n  \"?*\": \"qualifier\",\r\n  \"-\": \"contentSeparator\",\r\n  \"/\": \"property\",\r\n  \"/-\": \"property\",\r\n  \"@\": \"variableName.special\",\r\n  \"@-\": \"variableName.special\",\r\n  \"@++\": \"variableName.special\",\r\n  \"@+=\": \"variableName.special\",\r\n  \"@+=-\": \"variableName.special\",\r\n  \"@--\": \"variableName.special\",\r\n  \"@-=\": \"variableName.special\",\r\n  \"%+\": \"tag\",\r\n  \"%-\": \"tag\",\r\n  \"%\": \"tag\",\r\n  \">>\": \"tag\",\r\n  \"<<\": \"tag\",\r\n  \"<>\": \"tag\",\r\n  \"#\": \"tag\",  // Need to choose a style for this.\r\n  \"^\": \"attribute\",\r\n  \"^^\": \"attribute\",\r\n  \"^!\": \"attribute\",\r\n  \"*\": \"variable\",\r\n  \"**\": \"variable\",\r\n  \"\\\\\": \"keyword\",\r\n  \"\\\"\": \"comment\"\r\n};\r\n\r\n// Lines starting with these characters define scope (result in indentation).\r\nvar tlvScopePrefixChars = {\r\n  \"/\": \"beh-hier\",\r\n  \">\": \"beh-hier\",\r\n  \"-\": \"phys-hier\",\r\n  \"|\": \"pipe\",\r\n  \"?\": \"when\",\r\n  \"@\": \"stage\",\r\n  \"\\\\\": \"keyword\"\r\n};\r\nvar tlvIndentUnit = 3;\r\nvar tlvTrackStatements = false;\r\nvar tlvIdentMatch = /^([~!@#\\$%\\^&\\*-\\+=\\?\\/\\\\\\|'\"<>]+)([\\d\\w_]*)/;  // Matches an identifier.\r\n// Note that ':' is excluded, because of it's use in [:].\r\nvar tlvLineIndentationMatch = /^[! ] */;\r\nvar tlvCommentMatch = /^\\/[\\/\\*]/;\r\n\r\nexport const tlv = mkVerilog({\r\n  hooks: {\r\n    electricInput: false,\r\n\r\n    // Return undefined for verilog tokenizing, or style for TLV token (null not used).\r\n    // Standard CM styles are used for most formatting, but some TL-Verilog-specific highlighting\r\n    // can be enabled with the definition of cm-tlv-* styles, including highlighting for:\r\n    //   - M4 tokens\r\n    //   - TLV scope indentation\r\n    //   - Statement delimitation (enabled by tlvTrackStatements)\r\n    token: function(stream, state) {\r\n      var style = undefined;\r\n      var match;  // Return value of pattern matches.\r\n\r\n      // Set highlighting mode based on code region (TLV or SV).\r\n      if (stream.sol() && ! state.tlvInBlockComment) {\r\n        // Process region.\r\n        if (stream.peek() == '\\\\') {\r\n          style = \"def\";\r\n          stream.skipToEnd();\r\n          if (stream.string.match(/\\\\SV/)) {\r\n            state.tlvCodeActive = false;\r\n          } else if (stream.string.match(/\\\\TLV/)){\r\n            state.tlvCodeActive = true;\r\n          }\r\n        }\r\n        // Correct indentation in the face of a line prefix char.\r\n        if (state.tlvCodeActive && stream.pos == 0 &&\r\n            (state.indented == 0) && (match = stream.match(tlvLineIndentationMatch, false))) {\r\n          state.indented = match[0].length;\r\n        }\r\n\r\n        // Compute indentation state:\r\n        //   o Auto indentation on next line\r\n        //   o Indentation scope styles\r\n        var indented = state.indented;\r\n        var depth = indented / tlvIndentUnit;\r\n        if (depth <= state.tlvIndentationStyle.length) {\r\n          // not deeper than current scope\r\n\r\n          var blankline = stream.string.length == indented;\r\n          var chPos = depth * tlvIndentUnit;\r\n          if (chPos < stream.string.length) {\r\n            var bodyString = stream.string.slice(chPos);\r\n            var ch = bodyString[0];\r\n            if (tlvScopePrefixChars[ch] && ((match = bodyString.match(tlvIdentMatch)) &&\r\n                                            tlvIdentifierStyle[match[1]])) {\r\n              // This line begins scope.\r\n              // Next line gets indented one level.\r\n              indented += tlvIndentUnit;\r\n              // Style the next level of indentation (except non-region keyword identifiers,\r\n              //   which are statements themselves)\r\n              if (!(ch == \"\\\\\" && chPos > 0)) {\r\n                state.tlvIndentationStyle[depth] = tlvScopePrefixChars[ch];\r\n                if (tlvTrackStatements) {state.statementComment = false;}\r\n                depth++;\r\n              }\r\n            }\r\n          }\r\n          // Clear out deeper indentation levels unless line is blank.\r\n          if (!blankline) {\r\n            while (state.tlvIndentationStyle.length > depth) {\r\n              state.tlvIndentationStyle.pop();\r\n            }\r\n          }\r\n        }\r\n        // Set next level of indentation.\r\n        state.tlvNextIndent = indented;\r\n      }\r\n\r\n      if (state.tlvCodeActive) {\r\n        // Highlight as TLV.\r\n\r\n        var beginStatement = false;\r\n        if (tlvTrackStatements) {\r\n          // This starts a statement if the position is at the scope level\r\n          // and we're not within a statement leading comment.\r\n          beginStatement =\r\n            (stream.peek() != \" \") &&   // not a space\r\n            (style === undefined) &&    // not a region identifier\r\n            !state.tlvInBlockComment && // not in block comment\r\n            //!stream.match(tlvCommentMatch, false) && // not comment start\r\n          (stream.column() == state.tlvIndentationStyle.length * tlvIndentUnit);  // at scope level\r\n          if (beginStatement) {\r\n            if (state.statementComment) {\r\n              // statement already started by comment\r\n              beginStatement = false;\r\n            }\r\n            state.statementComment =\r\n              stream.match(tlvCommentMatch, false); // comment start\r\n          }\r\n        }\r\n\r\n        var match;\r\n        if (style !== undefined) {\r\n        } else if (state.tlvInBlockComment) {\r\n          // In a block comment.\r\n          if (stream.match(/^.*?\\*\\//)) {\r\n            // Exit block comment.\r\n            state.tlvInBlockComment = false;\r\n            if (tlvTrackStatements && !stream.eol()) {\r\n              // Anything after comment is assumed to be real statement content.\r\n              state.statementComment = false;\r\n            }\r\n          } else {\r\n            stream.skipToEnd();\r\n          }\r\n          style = \"comment\";\r\n        } else if ((match = stream.match(tlvCommentMatch)) && !state.tlvInBlockComment) {\r\n          // Start comment.\r\n          if (match[0] == \"//\") {\r\n            // Line comment.\r\n            stream.skipToEnd();\r\n          } else {\r\n            // Block comment.\r\n            state.tlvInBlockComment = true;\r\n          }\r\n          style = \"comment\";\r\n        } else if (match = stream.match(tlvIdentMatch)) {\r\n          // looks like an identifier (or identifier prefix)\r\n          var prefix = match[1];\r\n          var mnemonic = match[2];\r\n          if (// is identifier prefix\r\n            tlvIdentifierStyle.hasOwnProperty(prefix) &&\r\n              // has mnemonic or we're at the end of the line (maybe it hasn't been typed yet)\r\n            (mnemonic.length > 0 || stream.eol())) {\r\n            style = tlvIdentifierStyle[prefix];\r\n          } else {\r\n            // Just swallow one character and try again.\r\n            // This enables subsequent identifier match with preceding symbol character, which\r\n            //   is legal within a statement.  (Eg, !$reset).  It also enables detection of\r\n            //   comment start with preceding symbols.\r\n            stream.backUp(stream.current().length - 1);\r\n          }\r\n        } else if (stream.match(/^\\t+/)) {\r\n          // Highlight tabs, which are illegal.\r\n          style = \"invalid\";\r\n        } else if (stream.match(/^[\\[\\]{}\\(\\);\\:]+/)) {\r\n          // [:], (), {}, ;.\r\n          style = \"meta\";\r\n        } else if (match = stream.match(/^[mM]4([\\+_])?[\\w\\d_]*/)) {\r\n          // m4 pre proc\r\n          style = (match[1] == \"+\") ? \"keyword.special\" : \"keyword\";\r\n        } else if (stream.match(/^ +/)){\r\n          // Skip over spaces.\r\n          if (stream.eol()) {\r\n            // Trailing spaces.\r\n            style = \"error\";\r\n          }\r\n        } else if (stream.match(/^[\\w\\d_]+/)) {\r\n          // alpha-numeric token.\r\n          style = \"number\";\r\n        } else {\r\n          // Eat the next char w/ no formatting.\r\n          stream.next();\r\n        }\r\n      } else {\r\n        if (stream.match(/^[mM]4([\\w\\d_]*)/)) {\r\n          // m4 pre proc\r\n          style = \"keyword\";\r\n        }\r\n      }\r\n      return style;\r\n    },\r\n\r\n    indent: function(state) {\r\n      return (state.tlvCodeActive == true) ? state.tlvNextIndent : -1;\r\n    },\r\n\r\n    startState: function(state) {\r\n      state.tlvIndentationStyle = [];  // Styles to use for each level of indentation.\r\n      state.tlvCodeActive = true;  // True when we're in a TLV region (and at beginning of file).\r\n      state.tlvNextIndent = -1;    // The number of spaces to autoindent the next line if tlvCodeActive.\r\n      state.tlvInBlockComment = false;  // True inside /**/ comment.\r\n      if (tlvTrackStatements) {\r\n        state.statementComment = false;  // True inside a statement's header comment.\r\n      }\r\n    }\r\n\r\n  }\r\n});\r\n"],
  "mappings": "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",
  "names": ["words", "i"]
}
