{
  "version": 3,
  "sources": ["../../@codemirror/legacy-modes/mode/scheme.js"],
  "sourcesContent": ["var BUILTIN = \"builtin\", COMMENT = \"comment\", STRING = \"string\",\r\n    SYMBOL = \"symbol\", ATOM = \"atom\", NUMBER = \"number\", BRACKET = \"bracket\";\r\nvar INDENT_WORD_SKIP = 2;\r\n\r\nfunction makeKeywords(str) {\r\n  var obj = {}, words = str.split(\" \");\r\n  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\r\n  return obj;\r\n}\r\n\r\nvar keywords = makeKeywords(\"Î» case-lambda call/cc class cond-expand define-class define-values exit-handler field import inherit init-field interface let*-values let-values let/ec mixin opt-lambda override protect provide public rename require require-for-syntax syntax syntax-case syntax-error unit/sig unless when with-syntax and begin call-with-current-continuation call-with-input-file call-with-output-file case cond define define-syntax define-macro defmacro delay do dynamic-wind else for-each if lambda let let* let-syntax letrec letrec-syntax map or syntax-rules abs acos angle append apply asin assoc assq assv atan boolean? caar cadr call-with-input-file call-with-output-file call-with-values car cdddar cddddr cdr ceiling char->integer char-alphabetic? char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>? char-downcase char-lower-case? char-numeric? char-ready? char-upcase char-upper-case? char-whitespace? char<=? char<? char=? char>=? char>? char? close-input-port close-output-port complex? cons cos current-input-port current-output-port denominator display eof-object? eq? equal? eqv? eval even? exact->inexact exact? exp expt #f floor force gcd imag-part inexact->exact inexact? input-port? integer->char integer? interaction-environment lcm length list list->string list->vector list-ref list-tail list? load log magnitude make-polar make-rectangular make-string make-vector max member memq memv min modulo negative? newline not null-environment null? number->string number? numerator odd? open-input-file open-output-file output-port? pair? peek-char port? positive? procedure? quasiquote quote quotient rational? rationalize read read-char real-part real? remainder reverse round scheme-report-environment set! set-car! set-cdr! sin sqrt string string->list string->number string->symbol string-append string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>? string-copy string-fill! string-length string-ref string-set! string<=? string<? string=? string>=? string>? string? substring symbol->string symbol? #t tan transcript-off transcript-on truncate values vector vector->list vector-fill! vector-length vector-ref vector-set! with-input-from-file with-output-to-file write write-char zero?\");\r\nvar indentKeys = makeKeywords(\"define let letrec let* lambda define-macro defmacro let-syntax letrec-syntax let-values let*-values define-syntax syntax-rules define-values when unless\");\r\n\r\nfunction stateStack(indent, type, prev) { // represents a state stack object\r\n  this.indent = indent;\r\n  this.type = type;\r\n  this.prev = prev;\r\n}\r\n\r\nfunction pushStack(state, indent, type) {\r\n  state.indentStack = new stateStack(indent, type, state.indentStack);\r\n}\r\n\r\nfunction popStack(state) {\r\n  state.indentStack = state.indentStack.prev;\r\n}\r\n\r\nvar binaryMatcher = new RegExp(/^(?:[-+]i|[-+][01]+#*(?:\\/[01]+#*)?i|[-+]?[01]+#*(?:\\/[01]+#*)?@[-+]?[01]+#*(?:\\/[01]+#*)?|[-+]?[01]+#*(?:\\/[01]+#*)?[-+](?:[01]+#*(?:\\/[01]+#*)?)?i|[-+]?[01]+#*(?:\\/[01]+#*)?)(?=[()\\s;\"]|$)/i);\r\nvar octalMatcher = new RegExp(/^(?:[-+]i|[-+][0-7]+#*(?:\\/[0-7]+#*)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?@[-+]?[0-7]+#*(?:\\/[0-7]+#*)?|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?[-+](?:[0-7]+#*(?:\\/[0-7]+#*)?)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?)(?=[()\\s;\"]|$)/i);\r\nvar hexMatcher = new RegExp(/^(?:[-+]i|[-+][\\da-f]+#*(?:\\/[\\da-f]+#*)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?@[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?[-+](?:[\\da-f]+#*(?:\\/[\\da-f]+#*)?)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?)(?=[()\\s;\"]|$)/i);\r\nvar decimalMatcher = new RegExp(/^(?:[-+]i|[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)i|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)@[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)?i|(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*))(?=[()\\s;\"]|$)/i);\r\n\r\nfunction isBinaryNumber (stream) {\r\n  return stream.match(binaryMatcher);\r\n}\r\n\r\nfunction isOctalNumber (stream) {\r\n  return stream.match(octalMatcher);\r\n}\r\n\r\nfunction isDecimalNumber (stream, backup) {\r\n  if (backup === true) {\r\n    stream.backUp(1);\r\n  }\r\n  return stream.match(decimalMatcher);\r\n}\r\n\r\nfunction isHexNumber (stream) {\r\n  return stream.match(hexMatcher);\r\n}\r\n\r\nfunction processEscapedSequence(stream, options) {\r\n  var next, escaped = false;\r\n  while ((next = stream.next()) != null) {\r\n    if (next == options.token && !escaped) {\r\n      options.state.mode = false;\r\n      break;\r\n    }\r\n    escaped = !escaped && next == \"\\\\\";\r\n  }\r\n}\r\n\r\nexport const scheme = {\r\n  name: \"scheme\",\r\n  startState: function () {\r\n    return {\r\n      indentStack: null,\r\n      indentation: 0,\r\n      mode: false,\r\n      sExprComment: false,\r\n      sExprQuote: false\r\n    };\r\n  },\r\n\r\n  token: function (stream, state) {\r\n    if (state.indentStack == null && stream.sol()) {\r\n      // update indentation, but only if indentStack is empty\r\n      state.indentation = stream.indentation();\r\n    }\r\n\r\n    // skip spaces\r\n    if (stream.eatSpace()) {\r\n      return null;\r\n    }\r\n    var returnType = null;\r\n\r\n    switch(state.mode){\r\n    case \"string\": // multi-line string parsing mode\r\n      processEscapedSequence(stream, {\r\n        token: \"\\\"\",\r\n        state: state\r\n      });\r\n      returnType = STRING; // continue on in scheme-string mode\r\n      break;\r\n    case \"symbol\": // escape symbol\r\n      processEscapedSequence(stream, {\r\n        token: \"|\",\r\n        state: state\r\n      });\r\n      returnType = SYMBOL; // continue on in scheme-symbol mode\r\n      break;\r\n    case \"comment\": // comment parsing mode\r\n      var next, maybeEnd = false;\r\n      while ((next = stream.next()) != null) {\r\n        if (next == \"#\" && maybeEnd) {\r\n\r\n          state.mode = false;\r\n          break;\r\n        }\r\n        maybeEnd = (next == \"|\");\r\n      }\r\n      returnType = COMMENT;\r\n      break;\r\n    case \"s-expr-comment\": // s-expr commenting mode\r\n      state.mode = false;\r\n      if(stream.peek() == \"(\" || stream.peek() == \"[\"){\r\n        // actually start scheme s-expr commenting mode\r\n        state.sExprComment = 0;\r\n      }else{\r\n        // if not we just comment the entire of the next token\r\n        stream.eatWhile(/[^\\s\\(\\)\\[\\]]/); // eat symbol atom\r\n        returnType = COMMENT;\r\n        break;\r\n      }\r\n    default: // default parsing mode\r\n      var ch = stream.next();\r\n\r\n      if (ch == \"\\\"\") {\r\n        state.mode = \"string\";\r\n        returnType = STRING;\r\n\r\n      } else if (ch == \"'\") {\r\n        if (stream.peek() == \"(\" || stream.peek() == \"[\"){\r\n          if (typeof state.sExprQuote != \"number\") {\r\n            state.sExprQuote = 0;\r\n          } // else already in a quoted expression\r\n          returnType = ATOM;\r\n        } else {\r\n          stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\r\n          returnType = ATOM;\r\n        }\r\n      } else if (ch == '|') {\r\n        state.mode = \"symbol\";\r\n        returnType = SYMBOL;\r\n      } else if (ch == '#') {\r\n        if (stream.eat(\"|\")) {                    // Multi-line comment\r\n          state.mode = \"comment\"; // toggle to comment mode\r\n          returnType = COMMENT;\r\n        } else if (stream.eat(/[tf]/i)) {            // #t/#f (atom)\r\n          returnType = ATOM;\r\n        } else if (stream.eat(';')) {                // S-Expr comment\r\n          state.mode = \"s-expr-comment\";\r\n          returnType = COMMENT;\r\n        } else {\r\n          var numTest = null, hasExactness = false, hasRadix = true;\r\n          if (stream.eat(/[ei]/i)) {\r\n            hasExactness = true;\r\n          } else {\r\n            stream.backUp(1);       // must be radix specifier\r\n          }\r\n          if (stream.match(/^#b/i)) {\r\n            numTest = isBinaryNumber;\r\n          } else if (stream.match(/^#o/i)) {\r\n            numTest = isOctalNumber;\r\n          } else if (stream.match(/^#x/i)) {\r\n            numTest = isHexNumber;\r\n          } else if (stream.match(/^#d/i)) {\r\n            numTest = isDecimalNumber;\r\n          } else if (stream.match(/^[-+0-9.]/, false)) {\r\n            hasRadix = false;\r\n            numTest = isDecimalNumber;\r\n            // re-consume the initial # if all matches failed\r\n          } else if (!hasExactness) {\r\n            stream.eat('#');\r\n          }\r\n          if (numTest != null) {\r\n            if (hasRadix && !hasExactness) {\r\n              // consume optional exactness after radix\r\n              stream.match(/^#[ei]/i);\r\n            }\r\n            if (numTest(stream))\r\n              returnType = NUMBER;\r\n          }\r\n        }\r\n      } else if (/^[-+0-9.]/.test(ch) && isDecimalNumber(stream, true)) { // match non-prefixed number, must be decimal\r\n        returnType = NUMBER;\r\n      } else if (ch == \";\") { // comment\r\n        stream.skipToEnd(); // rest of the line is a comment\r\n        returnType = COMMENT;\r\n      } else if (ch == \"(\" || ch == \"[\") {\r\n        var keyWord = ''; var indentTemp = stream.column(), letter;\r\n        /**\r\n           Either\r\n           (indent-word ..\r\n           (non-indent-word ..\r\n           (;something else, bracket, etc.\r\n        */\r\n\r\n        while ((letter = stream.eat(/[^\\s\\(\\[\\;\\)\\]]/)) != null) {\r\n          keyWord += letter;\r\n        }\r\n\r\n        if (keyWord.length > 0 && indentKeys.propertyIsEnumerable(keyWord)) { // indent-word\r\n\r\n          pushStack(state, indentTemp + INDENT_WORD_SKIP, ch);\r\n        } else { // non-indent word\r\n          // we continue eating the spaces\r\n          stream.eatSpace();\r\n          if (stream.eol() || stream.peek() == \";\") {\r\n            // nothing significant after\r\n            // we restart indentation 1 space after\r\n            pushStack(state, indentTemp + 1, ch);\r\n          } else {\r\n            pushStack(state, indentTemp + stream.current().length, ch); // else we match\r\n          }\r\n        }\r\n        stream.backUp(stream.current().length - 1); // undo all the eating\r\n\r\n        if(typeof state.sExprComment == \"number\") state.sExprComment++;\r\n        if(typeof state.sExprQuote == \"number\") state.sExprQuote++;\r\n\r\n        returnType = BRACKET;\r\n      } else if (ch == \")\" || ch == \"]\") {\r\n        returnType = BRACKET;\r\n        if (state.indentStack != null && state.indentStack.type == (ch == \")\" ? \"(\" : \"[\")) {\r\n          popStack(state);\r\n\r\n          if(typeof state.sExprComment == \"number\"){\r\n            if(--state.sExprComment == 0){\r\n              returnType = COMMENT; // final closing bracket\r\n              state.sExprComment = false; // turn off s-expr commenting mode\r\n            }\r\n          }\r\n          if(typeof state.sExprQuote == \"number\"){\r\n            if(--state.sExprQuote == 0){\r\n              returnType = ATOM; // final closing bracket\r\n              state.sExprQuote = false; // turn off s-expr quote mode\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\r\n\r\n        if (keywords && keywords.propertyIsEnumerable(stream.current())) {\r\n          returnType = BUILTIN;\r\n        } else returnType = \"variable\";\r\n      }\r\n    }\r\n    return (typeof state.sExprComment == \"number\") ? COMMENT : ((typeof state.sExprQuote == \"number\") ? ATOM : returnType);\r\n  },\r\n\r\n  indent: function (state) {\r\n    if (state.indentStack == null) return state.indentation;\r\n    return state.indentStack.indent;\r\n  },\r\n\r\n  languageData: {\r\n    closeBrackets: {brackets: [\"(\", \"[\", \"{\", '\"']},\r\n    commentTokens: {line: \";;\"}\r\n  }\r\n};\r\n"],
  "mappings": "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",
  "names": []
}
