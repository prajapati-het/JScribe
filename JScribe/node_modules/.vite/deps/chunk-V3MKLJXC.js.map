{
  "version": 3,
  "sources": ["../../@codemirror/legacy-modes/mode/clike.js"],
  "sourcesContent": ["function Context(indented, column, type, info, align, prev) {\r\n  this.indented = indented;\r\n  this.column = column;\r\n  this.type = type;\r\n  this.info = info;\r\n  this.align = align;\r\n  this.prev = prev;\r\n}\r\nfunction pushContext(state, col, type, info) {\r\n  var indent = state.indented;\r\n  if (state.context && state.context.type == \"statement\" && type != \"statement\")\r\n    indent = state.context.indented;\r\n  return state.context = new Context(indent, col, type, info, null, state.context);\r\n}\r\nfunction popContext(state) {\r\n  var t = state.context.type;\r\n  if (t == \")\" || t == \"]\" || t == \"}\")\r\n    state.indented = state.context.indented;\r\n  return state.context = state.context.prev;\r\n}\r\n\r\nfunction typeBefore(stream, state, pos) {\r\n  if (state.prevToken == \"variable\" || state.prevToken == \"type\") return true;\r\n  if (/\\S(?:[^- ]>|[*\\]])\\s*$|\\*$/.test(stream.string.slice(0, pos))) return true;\r\n  if (state.typeAtEndOfLine && stream.column() == stream.indentation()) return true;\r\n}\r\n\r\nfunction isTopScope(context) {\r\n  for (;;) {\r\n    if (!context || context.type == \"top\") return true;\r\n    if (context.type == \"}\" && context.prev.info != \"namespace\") return false;\r\n    context = context.prev;\r\n  }\r\n}\r\n\r\nexport function clike(parserConfig) {\r\n  var statementIndentUnit = parserConfig.statementIndentUnit,\r\n      dontAlignCalls = parserConfig.dontAlignCalls,\r\n      keywords = parserConfig.keywords || {},\r\n      types = parserConfig.types || {},\r\n      builtin = parserConfig.builtin || {},\r\n      blockKeywords = parserConfig.blockKeywords || {},\r\n      defKeywords = parserConfig.defKeywords || {},\r\n      atoms = parserConfig.atoms || {},\r\n      hooks = parserConfig.hooks || {},\r\n      multiLineStrings = parserConfig.multiLineStrings,\r\n      indentStatements = parserConfig.indentStatements !== false,\r\n      indentSwitch = parserConfig.indentSwitch !== false,\r\n      namespaceSeparator = parserConfig.namespaceSeparator,\r\n      isPunctuationChar = parserConfig.isPunctuationChar || /[\\[\\]{}\\(\\),;\\:\\.]/,\r\n      numberStart = parserConfig.numberStart || /[\\d\\.]/,\r\n      number = parserConfig.number || /^(?:0x[a-f\\d]+|0b[01]+|(?:\\d+\\.?\\d*|\\.\\d+)(?:e[-+]?\\d+)?)(u|ll?|l|f)?/i,\r\n      isOperatorChar = parserConfig.isOperatorChar || /[+\\-*&%=<>!?|\\/]/,\r\n      isIdentifierChar = parserConfig.isIdentifierChar || /[\\w\\$_\\xa1-\\uffff]/,\r\n      // An optional function that takes a {string} token and returns true if it\r\n      // should be treated as a builtin.\r\n      isReservedIdentifier = parserConfig.isReservedIdentifier || false;\r\n\r\n  var curPunc, isDefKeyword;\r\n\r\n  function tokenBase(stream, state) {\r\n    var ch = stream.next();\r\n    if (hooks[ch]) {\r\n      var result = hooks[ch](stream, state);\r\n      if (result !== false) return result;\r\n    }\r\n    if (ch == '\"' || ch == \"'\") {\r\n      state.tokenize = tokenString(ch);\r\n      return state.tokenize(stream, state);\r\n    }\r\n    if (numberStart.test(ch)) {\r\n      stream.backUp(1)\r\n      if (stream.match(number)) return \"number\"\r\n      stream.next()\r\n    }\r\n    if (isPunctuationChar.test(ch)) {\r\n      curPunc = ch;\r\n      return null;\r\n    }\r\n    if (ch == \"/\") {\r\n      if (stream.eat(\"*\")) {\r\n        state.tokenize = tokenComment;\r\n        return tokenComment(stream, state);\r\n      }\r\n      if (stream.eat(\"/\")) {\r\n        stream.skipToEnd();\r\n        return \"comment\";\r\n      }\r\n    }\r\n    if (isOperatorChar.test(ch)) {\r\n      while (!stream.match(/^\\/[\\/*]/, false) && stream.eat(isOperatorChar)) {}\r\n      return \"operator\";\r\n    }\r\n    stream.eatWhile(isIdentifierChar);\r\n    if (namespaceSeparator) while (stream.match(namespaceSeparator))\r\n      stream.eatWhile(isIdentifierChar);\r\n\r\n    var cur = stream.current();\r\n    if (contains(keywords, cur)) {\r\n      if (contains(blockKeywords, cur)) curPunc = \"newstatement\";\r\n      if (contains(defKeywords, cur)) isDefKeyword = true;\r\n      return \"keyword\";\r\n    }\r\n    if (contains(types, cur)) return \"type\";\r\n    if (contains(builtin, cur)\r\n        || (isReservedIdentifier && isReservedIdentifier(cur))) {\r\n      if (contains(blockKeywords, cur)) curPunc = \"newstatement\";\r\n      return \"builtin\";\r\n    }\r\n    if (contains(atoms, cur)) return \"atom\";\r\n    return \"variable\";\r\n  }\r\n\r\n  function tokenString(quote) {\r\n    return function(stream, state) {\r\n      var escaped = false, next, end = false;\r\n      while ((next = stream.next()) != null) {\r\n        if (next == quote && !escaped) {end = true; break;}\r\n        escaped = !escaped && next == \"\\\\\";\r\n      }\r\n      if (end || !(escaped || multiLineStrings))\r\n        state.tokenize = null;\r\n      return \"string\";\r\n    };\r\n  }\r\n\r\n  function tokenComment(stream, state) {\r\n    var maybeEnd = false, ch;\r\n    while (ch = stream.next()) {\r\n      if (ch == \"/\" && maybeEnd) {\r\n        state.tokenize = null;\r\n        break;\r\n      }\r\n      maybeEnd = (ch == \"*\");\r\n    }\r\n    return \"comment\";\r\n  }\r\n\r\n  function maybeEOL(stream, state) {\r\n    if (parserConfig.typeFirstDefinitions && stream.eol() && isTopScope(state.context))\r\n      state.typeAtEndOfLine = typeBefore(stream, state, stream.pos)\r\n  }\r\n\r\n  // Interface\r\n\r\n  return {\r\n    name: parserConfig.name,\r\n    startState: function(indentUnit) {\r\n      return {\r\n        tokenize: null,\r\n        context: new Context(-indentUnit, 0, \"top\", null, false),\r\n        indented: 0,\r\n        startOfLine: true,\r\n        prevToken: null\r\n      };\r\n    },\r\n\r\n    token: function(stream, state) {\r\n      var ctx = state.context;\r\n      if (stream.sol()) {\r\n        if (ctx.align == null) ctx.align = false;\r\n        state.indented = stream.indentation();\r\n        state.startOfLine = true;\r\n      }\r\n      if (stream.eatSpace()) { maybeEOL(stream, state); return null; }\r\n      curPunc = isDefKeyword = null;\r\n      var style = (state.tokenize || tokenBase)(stream, state);\r\n      if (style == \"comment\" || style == \"meta\") return style;\r\n      if (ctx.align == null) ctx.align = true;\r\n\r\n      if (curPunc == \";\" || curPunc == \":\" || (curPunc == \",\" && stream.match(/^\\s*(?:\\/\\/.*)?$/, false)))\r\n        while (state.context.type == \"statement\") popContext(state);\r\n      else if (curPunc == \"{\") pushContext(state, stream.column(), \"}\");\r\n      else if (curPunc == \"[\") pushContext(state, stream.column(), \"]\");\r\n      else if (curPunc == \"(\") pushContext(state, stream.column(), \")\");\r\n      else if (curPunc == \"}\") {\r\n        while (ctx.type == \"statement\") ctx = popContext(state);\r\n        if (ctx.type == \"}\") ctx = popContext(state);\r\n        while (ctx.type == \"statement\") ctx = popContext(state);\r\n      }\r\n      else if (curPunc == ctx.type) popContext(state);\r\n      else if (indentStatements &&\r\n               (((ctx.type == \"}\" || ctx.type == \"top\") && curPunc != \";\") ||\r\n                (ctx.type == \"statement\" && curPunc == \"newstatement\"))) {\r\n        pushContext(state, stream.column(), \"statement\", stream.current());\r\n      }\r\n\r\n      if (style == \"variable\" &&\r\n          ((state.prevToken == \"def\" ||\r\n            (parserConfig.typeFirstDefinitions && typeBefore(stream, state, stream.start) &&\r\n             isTopScope(state.context) && stream.match(/^\\s*\\(/, false)))))\r\n        style = \"def\";\r\n\r\n      if (hooks.token) {\r\n        var result = hooks.token(stream, state, style);\r\n        if (result !== undefined) style = result;\r\n      }\r\n\r\n      if (style == \"def\" && parserConfig.styleDefs === false) style = \"variable\";\r\n\r\n      state.startOfLine = false;\r\n      state.prevToken = isDefKeyword ? \"def\" : style || curPunc;\r\n      maybeEOL(stream, state);\r\n      return style;\r\n    },\r\n\r\n    indent: function(state, textAfter, context) {\r\n      if (state.tokenize != tokenBase && state.tokenize != null || state.typeAtEndOfLine && isTopScope(state.context))\r\n        return null;\r\n      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);\r\n      var closing = firstChar == ctx.type;\r\n      if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\r\n      if (parserConfig.dontIndentStatements)\r\n        while (ctx.type == \"statement\" && parserConfig.dontIndentStatements.test(ctx.info))\r\n          ctx = ctx.prev\r\n      if (hooks.indent) {\r\n        var hook = hooks.indent(state, ctx, textAfter, context.unit);\r\n        if (typeof hook == \"number\") return hook\r\n      }\r\n      var switchBlock = ctx.prev && ctx.prev.info == \"switch\";\r\n      if (parserConfig.allmanIndentation && /[{(]/.test(firstChar)) {\r\n        while (ctx.type != \"top\" && ctx.type != \"}\") ctx = ctx.prev\r\n        return ctx.indented\r\n      }\r\n      if (ctx.type == \"statement\")\r\n        return ctx.indented + (firstChar == \"{\" ? 0 : statementIndentUnit || context.unit);\r\n      if (ctx.align && (!dontAlignCalls || ctx.type != \")\"))\r\n        return ctx.column + (closing ? 0 : 1);\r\n      if (ctx.type == \")\" && !closing)\r\n        return ctx.indented + (statementIndentUnit || context.unit);\r\n\r\n      return ctx.indented + (closing ? 0 : context.unit) +\r\n        (!closing && switchBlock && !/^(?:case|default)\\b/.test(textAfter) ? context.unit : 0);\r\n    },\r\n\r\n    languageData: {\r\n      indentOnInput: indentSwitch ? /^\\s*(?:case .*?:|default:|\\{\\}?|\\})$/ : /^\\s*[{}]$/,\r\n      commentTokens: {line: \"//\", block: {open: \"/*\", close: \"*/\"}},\r\n      autocomplete: Object.keys(keywords).concat(Object.keys(types)).concat(Object.keys(builtin)).concat(Object.keys(atoms)),\r\n      ...parserConfig.languageData\r\n    }\r\n  };\r\n};\r\n\r\nfunction words(str) {\r\n  var obj = {}, words = str.split(\" \");\r\n  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\r\n  return obj;\r\n}\r\nfunction contains(words, word) {\r\n  if (typeof words === \"function\") {\r\n    return words(word);\r\n  } else {\r\n    return words.propertyIsEnumerable(word);\r\n  }\r\n}\r\nvar cKeywords = \"auto if break case register continue return default do sizeof \" +\r\n    \"static else struct switch extern typedef union for goto while enum const \" +\r\n    \"volatile inline restrict asm fortran\";\r\n\r\n// Keywords from https://en.cppreference.com/w/cpp/keyword includes C++20.\r\nvar cppKeywords = \"alignas alignof and and_eq audit axiom bitand bitor catch \" +\r\n    \"class compl concept constexpr const_cast decltype delete dynamic_cast \" +\r\n    \"explicit export final friend import module mutable namespace new noexcept \" +\r\n    \"not not_eq operator or or_eq override private protected public \" +\r\n    \"reinterpret_cast requires static_assert static_cast template this \" +\r\n    \"thread_local throw try typeid typename using virtual xor xor_eq\";\r\n\r\nvar objCKeywords = \"bycopy byref in inout oneway out self super atomic nonatomic retain copy \" +\r\n    \"readwrite readonly strong weak assign typeof nullable nonnull null_resettable _cmd \" +\r\n    \"@interface @implementation @end @protocol @encode @property @synthesize @dynamic @class \" +\r\n    \"@public @package @private @protected @required @optional @try @catch @finally @import \" +\r\n    \"@selector @encode @defs @synchronized @autoreleasepool @compatibility_alias @available\";\r\n\r\nvar objCBuiltins = \"FOUNDATION_EXPORT FOUNDATION_EXTERN NS_INLINE NS_FORMAT_FUNCTION \" +\r\n    \" NS_RETURNS_RETAINEDNS_ERROR_ENUM NS_RETURNS_NOT_RETAINED NS_RETURNS_INNER_POINTER \" +\r\n    \"NS_DESIGNATED_INITIALIZER NS_ENUM NS_OPTIONS NS_REQUIRES_NIL_TERMINATION \" +\r\n    \"NS_ASSUME_NONNULL_BEGIN NS_ASSUME_NONNULL_END NS_SWIFT_NAME NS_REFINED_FOR_SWIFT\"\r\n\r\n// Do not use this. Use the cTypes function below. This is global just to avoid\r\n// excessive calls when cTypes is being called multiple times during a parse.\r\nvar basicCTypes = words(\"int long char short double float unsigned signed \" +\r\n                        \"void bool\");\r\n\r\n// Do not use this. Use the objCTypes function below. This is global just to avoid\r\n// excessive calls when objCTypes is being called multiple times during a parse.\r\nvar basicObjCTypes = words(\"SEL instancetype id Class Protocol BOOL\");\r\n\r\n// Returns true if identifier is a \"C\" type.\r\n// C type is defined as those that are reserved by the compiler (basicTypes),\r\n// and those that end in _t (Reserved by POSIX for types)\r\n// http://www.gnu.org/software/libc/manual/html_node/Reserved-Names.html\r\nfunction cTypes(identifier) {\r\n  return contains(basicCTypes, identifier) || /.+_t$/.test(identifier);\r\n}\r\n\r\n// Returns true if identifier is a \"Objective C\" type.\r\nfunction objCTypes(identifier) {\r\n  return cTypes(identifier) || contains(basicObjCTypes, identifier);\r\n}\r\n\r\nvar cBlockKeywords = \"case do else for if switch while struct enum union\";\r\nvar cDefKeywords = \"struct enum union\";\r\n\r\nfunction cppHook(stream, state) {\r\n  if (!state.startOfLine) return false\r\n  for (var ch, next = null; ch = stream.peek();) {\r\n    if (ch == \"\\\\\" && stream.match(/^.$/)) {\r\n      next = cppHook\r\n      break\r\n    } else if (ch == \"/\" && stream.match(/^\\/[\\/\\*]/, false)) {\r\n      break\r\n    }\r\n    stream.next()\r\n  }\r\n  state.tokenize = next\r\n  return \"meta\"\r\n}\r\n\r\nfunction pointerHook(_stream, state) {\r\n  if (state.prevToken == \"type\") return \"type\";\r\n  return false;\r\n}\r\n\r\n// For C and C++ (and ObjC): identifiers starting with __\r\n// or _ followed by a capital letter are reserved for the compiler.\r\nfunction cIsReservedIdentifier(token) {\r\n  if (!token || token.length < 2) return false;\r\n  if (token[0] != '_') return false;\r\n  return (token[1] == '_') || (token[1] !== token[1].toLowerCase());\r\n}\r\n\r\nfunction cpp14Literal(stream) {\r\n  stream.eatWhile(/[\\w\\.']/);\r\n  return \"number\";\r\n}\r\n\r\nfunction cpp11StringHook(stream, state) {\r\n  stream.backUp(1);\r\n  // Raw strings.\r\n  if (stream.match(/^(?:R|u8R|uR|UR|LR)/)) {\r\n    var match = stream.match(/^\"([^\\s\\\\()]{0,16})\\(/);\r\n    if (!match) {\r\n      return false;\r\n    }\r\n    state.cpp11RawStringDelim = match[1];\r\n    state.tokenize = tokenRawString;\r\n    return tokenRawString(stream, state);\r\n  }\r\n  // Unicode strings/chars.\r\n  if (stream.match(/^(?:u8|u|U|L)/)) {\r\n    if (stream.match(/^[\"']/, /* eat */ false)) {\r\n      return \"string\";\r\n    }\r\n    return false;\r\n  }\r\n  // Ignore this hook.\r\n  stream.next();\r\n  return false;\r\n}\r\n\r\nfunction cppLooksLikeConstructor(word) {\r\n  var lastTwo = /(\\w+)::~?(\\w+)$/.exec(word);\r\n  return lastTwo && lastTwo[1] == lastTwo[2];\r\n}\r\n\r\n// C#-style strings where \"\" escapes a quote.\r\nfunction tokenAtString(stream, state) {\r\n  var next;\r\n  while ((next = stream.next()) != null) {\r\n    if (next == '\"' && !stream.eat('\"')) {\r\n      state.tokenize = null;\r\n      break;\r\n    }\r\n  }\r\n  return \"string\";\r\n}\r\n\r\n// C++11 raw string literal is <prefix>\"<delim>( anything )<delim>\", where\r\n// <delim> can be a string up to 16 characters long.\r\nfunction tokenRawString(stream, state) {\r\n  // Escape characters that have special regex meanings.\r\n  var delim = state.cpp11RawStringDelim.replace(/[^\\w\\s]/g, '\\\\$&');\r\n  var match = stream.match(new RegExp(\".*?\\\\)\" + delim + '\"'));\r\n  if (match)\r\n    state.tokenize = null;\r\n  else\r\n    stream.skipToEnd();\r\n  return \"string\";\r\n}\r\n\r\nexport const c = clike({\r\n  name: \"c\",\r\n  keywords: words(cKeywords),\r\n  types: cTypes,\r\n  blockKeywords: words(cBlockKeywords),\r\n  defKeywords: words(cDefKeywords),\r\n  typeFirstDefinitions: true,\r\n  atoms: words(\"NULL true false\"),\r\n  isReservedIdentifier: cIsReservedIdentifier,\r\n  hooks: {\r\n    \"#\": cppHook,\r\n    \"*\": pointerHook,\r\n  }\r\n})\r\n\r\nexport const cpp = clike({\r\n  name: \"cpp\",\r\n  keywords: words(cKeywords + \" \" + cppKeywords),\r\n  types: cTypes,\r\n  blockKeywords: words(cBlockKeywords + \" class try catch\"),\r\n  defKeywords: words(cDefKeywords + \" class namespace\"),\r\n  typeFirstDefinitions: true,\r\n  atoms: words(\"true false NULL nullptr\"),\r\n  dontIndentStatements: /^template$/,\r\n  isIdentifierChar: /[\\w\\$_~\\xa1-\\uffff]/,\r\n  isReservedIdentifier: cIsReservedIdentifier,\r\n  hooks: {\r\n    \"#\": cppHook,\r\n    \"*\": pointerHook,\r\n    \"u\": cpp11StringHook,\r\n    \"U\": cpp11StringHook,\r\n    \"L\": cpp11StringHook,\r\n    \"R\": cpp11StringHook,\r\n    \"0\": cpp14Literal,\r\n    \"1\": cpp14Literal,\r\n    \"2\": cpp14Literal,\r\n    \"3\": cpp14Literal,\r\n    \"4\": cpp14Literal,\r\n    \"5\": cpp14Literal,\r\n    \"6\": cpp14Literal,\r\n    \"7\": cpp14Literal,\r\n    \"8\": cpp14Literal,\r\n    \"9\": cpp14Literal,\r\n    token: function(stream, state, style) {\r\n      if (style == \"variable\" && stream.peek() == \"(\" &&\r\n          (state.prevToken == \";\" || state.prevToken == null ||\r\n           state.prevToken == \"}\") &&\r\n          cppLooksLikeConstructor(stream.current()))\r\n        return \"def\";\r\n    }\r\n  },\r\n  namespaceSeparator: \"::\"\r\n});\r\n\r\nexport const java = clike({\r\n  name: \"java\",\r\n  keywords: words(\"abstract assert break case catch class const continue default \" +\r\n                  \"do else enum extends final finally for goto if implements import \" +\r\n                  \"instanceof interface native new package private protected public \" +\r\n                  \"return static strictfp super switch synchronized this throw throws transient \" +\r\n                  \"try volatile while @interface\"),\r\n  types: words(\"var byte short int long float double boolean char void Boolean Byte Character Double Float \" +\r\n               \"Integer Long Number Object Short String StringBuffer StringBuilder Void\"),\r\n  blockKeywords: words(\"catch class do else finally for if switch try while\"),\r\n  defKeywords: words(\"class interface enum @interface\"),\r\n  typeFirstDefinitions: true,\r\n  atoms: words(\"true false null\"),\r\n  number: /^(?:0x[a-f\\d_]+|0b[01_]+|(?:[\\d_]+\\.?\\d*|\\.\\d+)(?:e[-+]?[\\d_]+)?)(u|ll?|l|f)?/i,\r\n  hooks: {\r\n    \"@\": function(stream) {\r\n      // Don't match the @interface keyword.\r\n      if (stream.match('interface', false)) return false;\r\n\r\n      stream.eatWhile(/[\\w\\$_]/);\r\n      return \"meta\";\r\n    },\r\n    '\"': function(stream, state) {\r\n      if (!stream.match(/\"\"$/)) return false;\r\n      state.tokenize = tokenTripleString;\r\n      return state.tokenize(stream, state);\r\n    }\r\n  }\r\n})\r\n\r\nexport const csharp = clike({\r\n  name: \"csharp\",\r\n  keywords: words(\"abstract as async await base break case catch checked class const continue\" +\r\n                  \" default delegate do else enum event explicit extern finally fixed for\" +\r\n                  \" foreach goto if implicit in init interface internal is lock namespace new\" +\r\n                  \" operator out override params private protected public readonly record ref required return sealed\" +\r\n                  \" sizeof stackalloc static struct switch this throw try typeof unchecked\" +\r\n                  \" unsafe using virtual void volatile while add alias ascending descending dynamic from get\" +\r\n                  \" global group into join let orderby partial remove select set value var yield\"),\r\n  types: words(\"Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func\" +\r\n               \" Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32\" +\r\n               \" UInt64 bool byte char decimal double short int long object\"  +\r\n               \" sbyte float string ushort uint ulong\"),\r\n  blockKeywords: words(\"catch class do else finally for foreach if struct switch try while\"),\r\n  defKeywords: words(\"class interface namespace record struct var\"),\r\n  typeFirstDefinitions: true,\r\n  atoms: words(\"true false null\"),\r\n  hooks: {\r\n    \"@\": function(stream, state) {\r\n      if (stream.eat('\"')) {\r\n        state.tokenize = tokenAtString;\r\n        return tokenAtString(stream, state);\r\n      }\r\n      stream.eatWhile(/[\\w\\$_]/);\r\n      return \"meta\";\r\n    }\r\n  }\r\n});\r\n\r\nfunction tokenTripleString(stream, state) {\r\n  var escaped = false;\r\n  while (!stream.eol()) {\r\n    if (!escaped && stream.match('\"\"\"')) {\r\n      state.tokenize = null;\r\n      break;\r\n    }\r\n    escaped = stream.next() == \"\\\\\" && !escaped;\r\n  }\r\n  return \"string\";\r\n}\r\n\r\nfunction tokenNestedComment(depth) {\r\n  return function (stream, state) {\r\n    var ch\r\n    while (ch = stream.next()) {\r\n      if (ch == \"*\" && stream.eat(\"/\")) {\r\n        if (depth == 1) {\r\n          state.tokenize = null\r\n          break\r\n        } else {\r\n          state.tokenize = tokenNestedComment(depth - 1)\r\n          return state.tokenize(stream, state)\r\n        }\r\n      } else if (ch == \"/\" && stream.eat(\"*\")) {\r\n        state.tokenize = tokenNestedComment(depth + 1)\r\n        return state.tokenize(stream, state)\r\n      }\r\n    }\r\n    return \"comment\"\r\n  }\r\n}\r\n\r\nexport const scala = clike({\r\n  name: \"scala\",\r\n  keywords: words(\r\n    /* scala */\r\n    \"abstract case catch class def do else extends final finally for forSome if \" +\r\n      \"implicit import lazy match new null object override package private protected return \" +\r\n      \"sealed super this throw trait try type val var while with yield _ \" +\r\n\r\n    /* package scala */\r\n    \"assert assume require print println printf readLine readBoolean readByte readShort \" +\r\n      \"readChar readInt readLong readFloat readDouble\"\r\n  ),\r\n  types: words(\r\n    \"AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either \" +\r\n      \"Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable \" +\r\n      \"Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering \" +\r\n      \"Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder \" +\r\n      \"StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector \" +\r\n\r\n    /* package java.lang */\r\n    \"Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable \" +\r\n      \"Compiler Double Exception Float Integer Long Math Number Object Package Pair Process \" +\r\n      \"Runtime Runnable SecurityManager Short StackTraceElement StrictMath String \" +\r\n      \"StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void\"\r\n  ),\r\n  multiLineStrings: true,\r\n  blockKeywords: words(\"catch class enum do else finally for forSome if match switch try while\"),\r\n  defKeywords: words(\"class enum def object package trait type val var\"),\r\n  atoms: words(\"true false null\"),\r\n  indentStatements: false,\r\n  indentSwitch: false,\r\n  isOperatorChar: /[+\\-*&%=<>!?|\\/#:@]/,\r\n  hooks: {\r\n    \"@\": function(stream) {\r\n      stream.eatWhile(/[\\w\\$_]/);\r\n      return \"meta\";\r\n    },\r\n    '\"': function(stream, state) {\r\n      if (!stream.match('\"\"')) return false;\r\n      state.tokenize = tokenTripleString;\r\n      return state.tokenize(stream, state);\r\n    },\r\n    \"'\": function(stream) {\r\n      if (stream.match(/^(\\\\[^'\\s]+|[^\\\\'])'/)) return \"character\"\r\n      stream.eatWhile(/[\\w\\$_\\xa1-\\uffff]/);\r\n      return \"atom\";\r\n    },\r\n    \"=\": function(stream, state) {\r\n      var cx = state.context\r\n      if (cx.type == \"}\" && cx.align && stream.eat(\">\")) {\r\n        state.context = new Context(cx.indented, cx.column, cx.type, cx.info, null, cx.prev)\r\n        return \"operator\"\r\n      } else {\r\n        return false\r\n      }\r\n    },\r\n\r\n    \"/\": function(stream, state) {\r\n      if (!stream.eat(\"*\")) return false\r\n      state.tokenize = tokenNestedComment(1)\r\n      return state.tokenize(stream, state)\r\n    }\r\n  },\r\n  languageData: {\r\n    closeBrackets: {brackets: [\"(\", \"[\", \"{\", \"'\", '\"', '\"\"\"']}\r\n  }\r\n});\r\n\r\nfunction tokenKotlinString(tripleString){\r\n  return function (stream, state) {\r\n    var escaped = false, next, end = false;\r\n    while (!stream.eol()) {\r\n      if (!tripleString && !escaped && stream.match('\"') ) {end = true; break;}\r\n      if (tripleString && stream.match('\"\"\"')) {end = true; break;}\r\n      next = stream.next();\r\n      if(!escaped && next == \"$\" && stream.match('{'))\r\n        stream.skipTo(\"}\");\r\n      escaped = !escaped && next == \"\\\\\" && !tripleString;\r\n    }\r\n    if (end || !tripleString)\r\n      state.tokenize = null;\r\n    return \"string\";\r\n  }\r\n}\r\n\r\nexport const kotlin = clike({\r\n  name: \"kotlin\",\r\n  keywords: words(\r\n    /*keywords*/\r\n    \"package as typealias class interface this super val operator \" +\r\n      \"var fun for is in This throw return annotation \" +\r\n      \"break continue object if else while do try when !in !is as? \" +\r\n\r\n    /*soft keywords*/\r\n    \"file import where by get set abstract enum open inner override private public internal \" +\r\n      \"protected catch finally out final vararg reified dynamic companion constructor init \" +\r\n      \"sealed field property receiver param sparam lateinit data inline noinline tailrec \" +\r\n      \"external annotation crossinline const operator infix suspend actual expect setparam\"\r\n  ),\r\n  types: words(\r\n    /* package java.lang */\r\n    \"Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable \" +\r\n      \"Compiler Double Exception Float Integer Long Math Number Object Package Pair Process \" +\r\n      \"Runtime Runnable SecurityManager Short StackTraceElement StrictMath String \" +\r\n      \"StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void Annotation Any BooleanArray \" +\r\n      \"ByteArray Char CharArray DeprecationLevel DoubleArray Enum FloatArray Function Int IntArray Lazy \" +\r\n      \"LazyThreadSafetyMode LongArray Nothing ShortArray Unit\"\r\n  ),\r\n  intendSwitch: false,\r\n  indentStatements: false,\r\n  multiLineStrings: true,\r\n  number: /^(?:0x[a-f\\d_]+|0b[01_]+|(?:[\\d_]+(\\.\\d+)?|\\.\\d+)(?:e[-+]?[\\d_]+)?)(u|ll?|l|f)?/i,\r\n  blockKeywords: words(\"catch class do else finally for if where try while enum\"),\r\n  defKeywords: words(\"class val var object interface fun\"),\r\n  atoms: words(\"true false null this\"),\r\n  hooks: {\r\n    \"@\": function(stream) {\r\n      stream.eatWhile(/[\\w\\$_]/);\r\n      return \"meta\";\r\n    },\r\n    '*': function(_stream, state) {\r\n      return state.prevToken == '.' ? 'variable' : 'operator';\r\n    },\r\n    '\"': function(stream, state) {\r\n      state.tokenize = tokenKotlinString(stream.match('\"\"'));\r\n      return state.tokenize(stream, state);\r\n    },\r\n    \"/\": function(stream, state) {\r\n      if (!stream.eat(\"*\")) return false;\r\n      state.tokenize = tokenNestedComment(1);\r\n      return state.tokenize(stream, state)\r\n    },\r\n    indent: function(state, ctx, textAfter, indentUnit) {\r\n      var firstChar = textAfter && textAfter.charAt(0);\r\n      if ((state.prevToken == \"}\" || state.prevToken == \")\") && textAfter == \"\")\r\n        return state.indented;\r\n      if ((state.prevToken == \"operator\" && textAfter != \"}\" && state.context.type != \"}\") ||\r\n          state.prevToken == \"variable\" && firstChar == \".\" ||\r\n          (state.prevToken == \"}\" || state.prevToken == \")\") && firstChar == \".\")\r\n        return indentUnit * 2 + ctx.indented;\r\n      if (ctx.align && ctx.type == \"}\")\r\n        return ctx.indented + (state.context.type == (textAfter || \"\").charAt(0) ? 0 : indentUnit);\r\n    }\r\n  },\r\n  languageData: {\r\n    closeBrackets: {brackets: [\"(\", \"[\", \"{\", \"'\", '\"', '\"\"\"']}\r\n  }\r\n});\r\n\r\nexport const shader = clike({\r\n  name: \"shader\",\r\n  keywords: words(\"sampler1D sampler2D sampler3D samplerCube \" +\r\n                  \"sampler1DShadow sampler2DShadow \" +\r\n                  \"const attribute uniform varying \" +\r\n                  \"break continue discard return \" +\r\n                  \"for while do if else struct \" +\r\n                  \"in out inout\"),\r\n  types: words(\"float int bool void \" +\r\n               \"vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 \" +\r\n               \"mat2 mat3 mat4\"),\r\n  blockKeywords: words(\"for while do if else struct\"),\r\n  builtin: words(\"radians degrees sin cos tan asin acos atan \" +\r\n                 \"pow exp log exp2 sqrt inversesqrt \" +\r\n                 \"abs sign floor ceil fract mod min max clamp mix step smoothstep \" +\r\n                 \"length distance dot cross normalize ftransform faceforward \" +\r\n                 \"reflect refract matrixCompMult \" +\r\n                 \"lessThan lessThanEqual greaterThan greaterThanEqual \" +\r\n                 \"equal notEqual any all not \" +\r\n                 \"texture1D texture1DProj texture1DLod texture1DProjLod \" +\r\n                 \"texture2D texture2DProj texture2DLod texture2DProjLod \" +\r\n                 \"texture3D texture3DProj texture3DLod texture3DProjLod \" +\r\n                 \"textureCube textureCubeLod \" +\r\n                 \"shadow1D shadow2D shadow1DProj shadow2DProj \" +\r\n                 \"shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod \" +\r\n                 \"dFdx dFdy fwidth \" +\r\n                 \"noise1 noise2 noise3 noise4\"),\r\n  atoms: words(\"true false \" +\r\n               \"gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex \" +\r\n               \"gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 \" +\r\n               \"gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 \" +\r\n               \"gl_FogCoord gl_PointCoord \" +\r\n               \"gl_Position gl_PointSize gl_ClipVertex \" +\r\n               \"gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor \" +\r\n               \"gl_TexCoord gl_FogFragCoord \" +\r\n               \"gl_FragCoord gl_FrontFacing \" +\r\n               \"gl_FragData gl_FragDepth \" +\r\n               \"gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix \" +\r\n               \"gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse \" +\r\n               \"gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse \" +\r\n               \"gl_TextureMatrixTranspose gl_ModelViewMatrixInverseTranspose \" +\r\n               \"gl_ProjectionMatrixInverseTranspose \" +\r\n               \"gl_ModelViewProjectionMatrixInverseTranspose \" +\r\n               \"gl_TextureMatrixInverseTranspose \" +\r\n               \"gl_NormalScale gl_DepthRange gl_ClipPlane \" +\r\n               \"gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel \" +\r\n               \"gl_FrontLightModelProduct gl_BackLightModelProduct \" +\r\n               \"gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ \" +\r\n               \"gl_FogParameters \" +\r\n               \"gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords \" +\r\n               \"gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats \" +\r\n               \"gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits \" +\r\n               \"gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits \" +\r\n               \"gl_MaxDrawBuffers\"),\r\n  indentSwitch: false,\r\n  hooks: {\"#\": cppHook}\r\n})\r\n\r\nexport const nesC = clike({\r\n  name: \"nesc\",\r\n  keywords: words(cKeywords + \" as atomic async call command component components configuration event generic \" +\r\n                  \"implementation includes interface module new norace nx_struct nx_union post provides \" +\r\n                  \"signal task uses abstract extends\"),\r\n  types: cTypes,\r\n  blockKeywords: words(cBlockKeywords),\r\n  atoms: words(\"null true false\"),\r\n  hooks: {\"#\": cppHook}\r\n})\r\n\r\nexport const objectiveC = clike({\r\n  name: \"objectivec\",\r\n  keywords: words(cKeywords + \" \" + objCKeywords),\r\n  types: objCTypes,\r\n  builtin: words(objCBuiltins),\r\n  blockKeywords: words(cBlockKeywords + \" @synthesize @try @catch @finally @autoreleasepool @synchronized\"),\r\n  defKeywords: words(cDefKeywords + \" @interface @implementation @protocol @class\"),\r\n  dontIndentStatements: /^@.*$/,\r\n  typeFirstDefinitions: true,\r\n  atoms: words(\"YES NO NULL Nil nil true false nullptr\"),\r\n  isReservedIdentifier: cIsReservedIdentifier,\r\n  hooks: {\r\n    \"#\": cppHook,\r\n    \"*\": pointerHook,\r\n  }\r\n})\r\n\r\nexport const objectiveCpp = clike({\r\n  name: \"objectivecpp\",\r\n  keywords: words(cKeywords + \" \" + objCKeywords + \" \" + cppKeywords),\r\n  types: objCTypes,\r\n  builtin: words(objCBuiltins),\r\n  blockKeywords: words(cBlockKeywords + \" @synthesize @try @catch @finally @autoreleasepool @synchronized class try catch\"),\r\n  defKeywords: words(cDefKeywords + \" @interface @implementation @protocol @class class namespace\"),\r\n  dontIndentStatements: /^@.*$|^template$/,\r\n  typeFirstDefinitions: true,\r\n  atoms: words(\"YES NO NULL Nil nil true false nullptr\"),\r\n  isReservedIdentifier: cIsReservedIdentifier,\r\n  hooks: {\r\n    \"#\": cppHook,\r\n    \"*\": pointerHook,\r\n    \"u\": cpp11StringHook,\r\n    \"U\": cpp11StringHook,\r\n    \"L\": cpp11StringHook,\r\n    \"R\": cpp11StringHook,\r\n    \"0\": cpp14Literal,\r\n    \"1\": cpp14Literal,\r\n    \"2\": cpp14Literal,\r\n    \"3\": cpp14Literal,\r\n    \"4\": cpp14Literal,\r\n    \"5\": cpp14Literal,\r\n    \"6\": cpp14Literal,\r\n    \"7\": cpp14Literal,\r\n    \"8\": cpp14Literal,\r\n    \"9\": cpp14Literal,\r\n    token: function(stream, state, style) {\r\n      if (style == \"variable\" && stream.peek() == \"(\" &&\r\n          (state.prevToken == \";\" || state.prevToken == null ||\r\n           state.prevToken == \"}\") &&\r\n          cppLooksLikeConstructor(stream.current()))\r\n        return \"def\";\r\n    }\r\n  },\r\n  namespaceSeparator: \"::\"\r\n})\r\n\r\nexport const squirrel = clike({\r\n  name: \"squirrel\",\r\n  keywords: words(\"base break clone continue const default delete enum extends function in class\" +\r\n                  \" foreach local resume return this throw typeof yield constructor instanceof static\"),\r\n  types: cTypes,\r\n  blockKeywords: words(\"case catch class else for foreach if switch try while\"),\r\n  defKeywords: words(\"function local class\"),\r\n  typeFirstDefinitions: true,\r\n  atoms: words(\"true false null\"),\r\n  hooks: {\"#\": cppHook}\r\n})\r\n\r\n// Ceylon Strings need to deal with interpolation\r\nvar stringTokenizer = null;\r\nfunction tokenCeylonString(type) {\r\n  return function(stream, state) {\r\n    var escaped = false, next, end = false;\r\n    while (!stream.eol()) {\r\n      if (!escaped && stream.match('\"') &&\r\n          (type == \"single\" || stream.match('\"\"'))) {\r\n        end = true;\r\n        break;\r\n      }\r\n      if (!escaped && stream.match('``')) {\r\n        stringTokenizer = tokenCeylonString(type);\r\n        end = true;\r\n        break;\r\n      }\r\n      next = stream.next();\r\n      escaped = type == \"single\" && !escaped && next == \"\\\\\";\r\n    }\r\n    if (end)\r\n      state.tokenize = null;\r\n    return \"string\";\r\n  }\r\n}\r\n\r\nexport const ceylon = clike({\r\n  name: \"ceylon\",\r\n  keywords: words(\"abstracts alias assembly assert assign break case catch class continue dynamic else\" +\r\n                  \" exists extends finally for function given if import in interface is let module new\" +\r\n                  \" nonempty object of out outer package return satisfies super switch then this throw\" +\r\n                  \" try value void while\"),\r\n  types: function(word) {\r\n    // In Ceylon all identifiers that start with an uppercase are types\r\n    var first = word.charAt(0);\r\n    return (first === first.toUpperCase() && first !== first.toLowerCase());\r\n  },\r\n  blockKeywords: words(\"case catch class dynamic else finally for function if interface module new object switch try while\"),\r\n  defKeywords: words(\"class dynamic function interface module object package value\"),\r\n  builtin: words(\"abstract actual aliased annotation by default deprecated doc final formal late license\" +\r\n                 \" native optional sealed see serializable shared suppressWarnings tagged throws variable\"),\r\n  isPunctuationChar: /[\\[\\]{}\\(\\),;\\:\\.`]/,\r\n  isOperatorChar: /[+\\-*&%=<>!?|^~:\\/]/,\r\n  numberStart: /[\\d#$]/,\r\n  number: /^(?:#[\\da-fA-F_]+|\\$[01_]+|[\\d_]+[kMGTPmunpf]?|[\\d_]+\\.[\\d_]+(?:[eE][-+]?\\d+|[kMGTPmunpf]|)|)/i,\r\n  multiLineStrings: true,\r\n  typeFirstDefinitions: true,\r\n  atoms: words(\"true false null larger smaller equal empty finished\"),\r\n  indentSwitch: false,\r\n  styleDefs: false,\r\n  hooks: {\r\n    \"@\": function(stream) {\r\n      stream.eatWhile(/[\\w\\$_]/);\r\n      return \"meta\";\r\n    },\r\n    '\"': function(stream, state) {\r\n      state.tokenize = tokenCeylonString(stream.match('\"\"') ? \"triple\" : \"single\");\r\n      return state.tokenize(stream, state);\r\n    },\r\n    '`': function(stream, state) {\r\n      if (!stringTokenizer || !stream.match('`')) return false;\r\n      state.tokenize = stringTokenizer;\r\n      stringTokenizer = null;\r\n      return state.tokenize(stream, state);\r\n    },\r\n    \"'\": function(stream) {\r\n      if (stream.match(/^(\\\\[^'\\s]+|[^\\\\'])'/)) return \"string.special\"\r\n      stream.eatWhile(/[\\w\\$_\\xa1-\\uffff]/);\r\n      return \"atom\";\r\n    },\r\n    token: function(_stream, state, style) {\r\n      if ((style == \"variable\" || style == \"type\") &&\r\n          state.prevToken == \".\") {\r\n        return \"variableName.special\";\r\n      }\r\n    }\r\n  },\r\n  languageData: {\r\n    closeBrackets: {brackets: [\"(\", \"[\", \"{\", \"'\", '\"', '\"\"\"']}\r\n  }\r\n})\r\n\r\nfunction pushInterpolationStack(state) {\r\n  (state.interpolationStack || (state.interpolationStack = [])).push(state.tokenize);\r\n}\r\n\r\nfunction popInterpolationStack(state) {\r\n  return (state.interpolationStack || (state.interpolationStack = [])).pop();\r\n}\r\n\r\nfunction sizeInterpolationStack(state) {\r\n  return state.interpolationStack ? state.interpolationStack.length : 0;\r\n}\r\n\r\nfunction tokenDartString(quote, stream, state, raw) {\r\n  var tripleQuoted = false;\r\n  if (stream.eat(quote)) {\r\n    if (stream.eat(quote)) tripleQuoted = true;\r\n    else return \"string\"; //empty string\r\n  }\r\n  function tokenStringHelper(stream, state) {\r\n    var escaped = false;\r\n    while (!stream.eol()) {\r\n      if (!raw && !escaped && stream.peek() == \"$\") {\r\n        pushInterpolationStack(state);\r\n        state.tokenize = tokenInterpolation;\r\n        return \"string\";\r\n      }\r\n      var next = stream.next();\r\n      if (next == quote && !escaped && (!tripleQuoted || stream.match(quote + quote))) {\r\n        state.tokenize = null;\r\n        break;\r\n      }\r\n      escaped = !raw && !escaped && next == \"\\\\\";\r\n    }\r\n    return \"string\";\r\n  }\r\n  state.tokenize = tokenStringHelper;\r\n  return tokenStringHelper(stream, state);\r\n}\r\n\r\nfunction tokenInterpolation(stream, state) {\r\n  stream.eat(\"$\");\r\n  if (stream.eat(\"{\")) {\r\n    // let clike handle the content of ${...},\r\n    // we take over again when \"}\" appears (see hooks).\r\n    state.tokenize = null;\r\n  } else {\r\n    state.tokenize = tokenInterpolationIdentifier;\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction tokenInterpolationIdentifier(stream, state) {\r\n  stream.eatWhile(/[\\w_]/);\r\n  state.tokenize = popInterpolationStack(state);\r\n  return \"variable\";\r\n}\r\n\r\nexport const dart = clike({\r\n  name: \"dart\",\r\n  keywords: words(\"this super static final const abstract class extends external factory \" +\r\n                  \"implements mixin get native set typedef with enum throw rethrow assert break case \" +\r\n                  \"continue default in return new deferred async await covariant try catch finally \" +\r\n                  \"do else for if switch while import library export part of show hide is as extension \" +\r\n                  \"on yield late required sealed base interface when inline\"),\r\n  blockKeywords: words(\"try catch finally do else for if switch while\"),\r\n  builtin: words(\"void bool num int double dynamic var String Null Never\"),\r\n  atoms: words(\"true false null\"),\r\n  hooks: {\r\n    \"@\": function(stream) {\r\n      stream.eatWhile(/[\\w\\$_\\.]/);\r\n      return \"meta\";\r\n    },\r\n\r\n    // custom string handling to deal with triple-quoted strings and string interpolation\r\n    \"'\": function(stream, state) {\r\n      return tokenDartString(\"'\", stream, state, false);\r\n    },\r\n    \"\\\"\": function(stream, state) {\r\n      return tokenDartString(\"\\\"\", stream, state, false);\r\n    },\r\n    \"r\": function(stream, state) {\r\n      var peek = stream.peek();\r\n      if (peek == \"'\" || peek == \"\\\"\") {\r\n        return tokenDartString(stream.next(), stream, state, true);\r\n      }\r\n      return false;\r\n    },\r\n\r\n    \"}\": function(_stream, state) {\r\n      // \"}\" is end of interpolation, if interpolation stack is non-empty\r\n      if (sizeInterpolationStack(state) > 0) {\r\n        state.tokenize = popInterpolationStack(state);\r\n        return null;\r\n      }\r\n      return false;\r\n    },\r\n\r\n    \"/\": function(stream, state) {\r\n      if (!stream.eat(\"*\")) return false\r\n      state.tokenize = tokenNestedComment(1)\r\n      return state.tokenize(stream, state)\r\n    },\r\n    token: function(stream, _, style) {\r\n      if (style == \"variable\") {\r\n        // Assume uppercase symbols are classes\r\n        var isUpper = RegExp('^[_$]*[A-Z][a-zA-Z0-9_$]*$','g');\r\n        if (isUpper.test(stream.current())) {\r\n          return 'type';\r\n        }\r\n      }\r\n    }\r\n  }\r\n})\r\n"],
  "mappings": "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",
  "names": ["words", "stream", "state"]
}
