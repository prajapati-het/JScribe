{
  "version": 3,
  "sources": ["../../@codemirror/legacy-modes/mode/puppet.js"],
  "sourcesContent": ["// Stores the words from the define method\r\nvar words = {};\r\n// Taken, mostly, from the Puppet official variable standards regex\r\nvar variable_regex = /({)?([a-z][a-z0-9_]*)?((::[a-z][a-z0-9_]*)*::)?[a-zA-Z0-9_]+(})?/;\r\n\r\n// Takes a string of words separated by spaces and adds them as\r\n// keys with the value of the first argument 'style'\r\nfunction define(style, string) {\r\n  var split = string.split(' ');\r\n  for (var i = 0; i < split.length; i++) {\r\n    words[split[i]] = style;\r\n  }\r\n}\r\n\r\n// Takes commonly known puppet types/words and classifies them to a style\r\ndefine('keyword', 'class define site node include import inherits');\r\ndefine('keyword', 'case if else in and elsif default or');\r\ndefine('atom', 'false true running present absent file directory undef');\r\ndefine('builtin', 'action augeas burst chain computer cron destination dport exec ' +\r\n       'file filebucket group host icmp iniface interface jump k5login limit log_level ' +\r\n       'log_prefix macauthorization mailalias maillist mcx mount nagios_command ' +\r\n       'nagios_contact nagios_contactgroup nagios_host nagios_hostdependency ' +\r\n       'nagios_hostescalation nagios_hostextinfo nagios_hostgroup nagios_service ' +\r\n       'nagios_servicedependency nagios_serviceescalation nagios_serviceextinfo ' +\r\n       'nagios_servicegroup nagios_timeperiod name notify outiface package proto reject ' +\r\n       'resources router schedule scheduled_task selboolean selmodule service source ' +\r\n       'sport ssh_authorized_key sshkey stage state table tidy todest toports tosource ' +\r\n       'user vlan yumrepo zfs zone zpool');\r\n\r\n// After finding a start of a string ('|\") this function attempts to find the end;\r\n// If a variable is encountered along the way, we display it differently when it\r\n// is encapsulated in a double-quoted string.\r\nfunction tokenString(stream, state) {\r\n  var current, prev, found_var = false;\r\n  while (!stream.eol() && (current = stream.next()) != state.pending) {\r\n    if (current === '$' && prev != '\\\\' && state.pending == '\"') {\r\n      found_var = true;\r\n      break;\r\n    }\r\n    prev = current;\r\n  }\r\n  if (found_var) {\r\n    stream.backUp(1);\r\n  }\r\n  if (current == state.pending) {\r\n    state.continueString = false;\r\n  } else {\r\n    state.continueString = true;\r\n  }\r\n  return \"string\";\r\n}\r\n\r\n// Main function\r\nfunction tokenize(stream, state) {\r\n  // Matches one whole word\r\n  var word = stream.match(/[\\w]+/, false);\r\n  // Matches attributes (i.e. ensure => present ; 'ensure' would be matched)\r\n  var attribute = stream.match(/(\\s+)?\\w+\\s+=>.*/, false);\r\n  // Matches non-builtin resource declarations\r\n  // (i.e. \"apache::vhost {\" or \"mycustomclasss {\" would be matched)\r\n  var resource = stream.match(/(\\s+)?[\\w:_]+(\\s+)?{/, false);\r\n  // Matches virtual and exported resources (i.e. @@user { ; and the like)\r\n  var special_resource = stream.match(/(\\s+)?[@]{1,2}[\\w:_]+(\\s+)?{/, false);\r\n\r\n  // Finally advance the stream\r\n  var ch = stream.next();\r\n\r\n  // Have we found a variable?\r\n  if (ch === '$') {\r\n    if (stream.match(variable_regex)) {\r\n      // If so, and its in a string, assign it a different color\r\n      return state.continueString ? 'variableName.special' : 'variable';\r\n    }\r\n    // Otherwise return an invalid variable\r\n    return \"error\";\r\n  }\r\n  // Should we still be looking for the end of a string?\r\n  if (state.continueString) {\r\n    // If so, go through the loop again\r\n    stream.backUp(1);\r\n    return tokenString(stream, state);\r\n  }\r\n  // Are we in a definition (class, node, define)?\r\n  if (state.inDefinition) {\r\n    // If so, return def (i.e. for 'class myclass {' ; 'myclass' would be matched)\r\n    if (stream.match(/(\\s+)?[\\w:_]+(\\s+)?/)) {\r\n      return 'def';\r\n    }\r\n    // Match the rest it the next time around\r\n    stream.match(/\\s+{/);\r\n    state.inDefinition = false;\r\n  }\r\n  // Are we in an 'include' statement?\r\n  if (state.inInclude) {\r\n    // Match and return the included class\r\n    stream.match(/(\\s+)?\\S+(\\s+)?/);\r\n    state.inInclude = false;\r\n    return 'def';\r\n  }\r\n  // Do we just have a function on our hands?\r\n  // In 'ensure_resource(\"myclass\")', 'ensure_resource' is matched\r\n  if (stream.match(/(\\s+)?\\w+\\(/)) {\r\n    stream.backUp(1);\r\n    return 'def';\r\n  }\r\n  // Have we matched the prior attribute regex?\r\n  if (attribute) {\r\n    stream.match(/(\\s+)?\\w+/);\r\n    return 'tag';\r\n  }\r\n  // Do we have Puppet specific words?\r\n  if (word && words.hasOwnProperty(word)) {\r\n    // Negates the initial next()\r\n    stream.backUp(1);\r\n    // rs move the stream\r\n    stream.match(/[\\w]+/);\r\n    // We want to process these words differently\r\n    // do to the importance they have in Puppet\r\n    if (stream.match(/\\s+\\S+\\s+{/, false)) {\r\n      state.inDefinition = true;\r\n    }\r\n    if (word == 'include') {\r\n      state.inInclude = true;\r\n    }\r\n    // Returns their value as state in the prior define methods\r\n    return words[word];\r\n  }\r\n  // Is there a match on a reference?\r\n  if (/(^|\\s+)[A-Z][\\w:_]+/.test(word)) {\r\n    // Negate the next()\r\n    stream.backUp(1);\r\n    // Match the full reference\r\n    stream.match(/(^|\\s+)[A-Z][\\w:_]+/);\r\n    return 'def';\r\n  }\r\n  // Have we matched the prior resource regex?\r\n  if (resource) {\r\n    stream.match(/(\\s+)?[\\w:_]+/);\r\n    return 'def';\r\n  }\r\n  // Have we matched the prior special_resource regex?\r\n  if (special_resource) {\r\n    stream.match(/(\\s+)?[@]{1,2}/);\r\n    return 'atom';\r\n  }\r\n  // Match all the comments. All of them.\r\n  if (ch == \"#\") {\r\n    stream.skipToEnd();\r\n    return \"comment\";\r\n  }\r\n  // Have we found a string?\r\n  if (ch == \"'\" || ch == '\"') {\r\n    // Store the type (single or double)\r\n    state.pending = ch;\r\n    // Perform the looping function to find the end\r\n    return tokenString(stream, state);\r\n  }\r\n  // Match all the brackets\r\n  if (ch == '{' || ch == '}') {\r\n    return 'bracket';\r\n  }\r\n  // Match characters that we are going to assume\r\n  // are trying to be regex\r\n  if (ch == '/') {\r\n    stream.match(/^[^\\/]*\\//);\r\n    return 'string.special';\r\n  }\r\n  // Match all the numbers\r\n  if (ch.match(/[0-9]/)) {\r\n    stream.eatWhile(/[0-9]+/);\r\n    return 'number';\r\n  }\r\n  // Match the '=' and '=>' operators\r\n  if (ch == '=') {\r\n    if (stream.peek() == '>') {\r\n      stream.next();\r\n    }\r\n    return \"operator\";\r\n  }\r\n  // Keep advancing through all the rest\r\n  stream.eatWhile(/[\\w-]/);\r\n  // Return a blank line for everything else\r\n  return null;\r\n}\r\n// Start it all\r\nexport const puppet = {\r\n  name: \"puppet\",\r\n\r\n  startState: function () {\r\n    var state = {};\r\n    state.inDefinition = false;\r\n    state.inInclude = false;\r\n    state.continueString = false;\r\n    state.pending = false;\r\n    return state;\r\n  },\r\n  token: function (stream, state) {\r\n    // Strip the spaces, but regex will account for them eitherway\r\n    if (stream.eatSpace()) return null;\r\n    // Go through the main process\r\n    return tokenize(stream, state);\r\n  }\r\n};\r\n"],
  "mappings": "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",
  "names": []
}
