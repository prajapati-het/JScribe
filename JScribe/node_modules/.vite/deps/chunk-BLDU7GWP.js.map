{
  "version": 3,
  "sources": ["../../@codemirror/legacy-modes/mode/haxe.js"],
  "sourcesContent": ["// Tokenizer\r\n\r\nfunction kw(type) {return {type: type, style: \"keyword\"};}\r\nvar A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\r\nvar operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"}, attribute = {type:\"attribute\", style: \"attribute\"};\r\nvar type = kw(\"typedef\");\r\nvar keywords = {\r\n  \"if\": A, \"while\": A, \"else\": B, \"do\": B, \"try\": B,\r\n  \"return\": C, \"break\": C, \"continue\": C, \"new\": C, \"throw\": C,\r\n  \"var\": kw(\"var\"), \"inline\":attribute, \"static\": attribute, \"using\":kw(\"import\"),\r\n  \"public\": attribute, \"private\": attribute, \"cast\": kw(\"cast\"), \"import\": kw(\"import\"), \"macro\": kw(\"macro\"),\r\n  \"function\": kw(\"function\"), \"catch\": kw(\"catch\"), \"untyped\": kw(\"untyped\"), \"callback\": kw(\"cb\"),\r\n  \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\r\n  \"in\": operator, \"never\": kw(\"property_access\"), \"trace\":kw(\"trace\"),\r\n  \"class\": type, \"abstract\":type, \"enum\":type, \"interface\":type, \"typedef\":type, \"extends\":type, \"implements\":type, \"dynamic\":type,\r\n  \"true\": atom, \"false\": atom, \"null\": atom\r\n};\r\n\r\nvar isOperatorChar = /[+\\-*&%=<>!?|]/;\r\n\r\nfunction chain(stream, state, f) {\r\n  state.tokenize = f;\r\n  return f(stream, state);\r\n}\r\n\r\nfunction toUnescaped(stream, end) {\r\n  var escaped = false, next;\r\n  while ((next = stream.next()) != null) {\r\n    if (next == end && !escaped)\r\n      return true;\r\n    escaped = !escaped && next == \"\\\\\";\r\n  }\r\n}\r\n\r\n// Used as scratch variables to communicate multiple values without\r\n// consing up tons of objects.\r\nvar type, content;\r\nfunction ret(tp, style, cont) {\r\n  type = tp; content = cont;\r\n  return style;\r\n}\r\n\r\nfunction haxeTokenBase(stream, state) {\r\n  var ch = stream.next();\r\n  if (ch == '\"' || ch == \"'\") {\r\n    return chain(stream, state, haxeTokenString(ch));\r\n  } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\r\n    return ret(ch);\r\n  } else if (ch == \"0\" && stream.eat(/x/i)) {\r\n    stream.eatWhile(/[\\da-f]/i);\r\n    return ret(\"number\", \"number\");\r\n  } else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\r\n    stream.match(/^\\d*(?:\\.\\d*(?!\\.))?(?:[eE][+\\-]?\\d+)?/);\r\n    return ret(\"number\", \"number\");\r\n  } else if (state.reAllowed && (ch == \"~\" && stream.eat(/\\//))) {\r\n    toUnescaped(stream, \"/\");\r\n    stream.eatWhile(/[gimsu]/);\r\n    return ret(\"regexp\", \"string.special\");\r\n  } else if (ch == \"/\") {\r\n    if (stream.eat(\"*\")) {\r\n      return chain(stream, state, haxeTokenComment);\r\n    } else if (stream.eat(\"/\")) {\r\n      stream.skipToEnd();\r\n      return ret(\"comment\", \"comment\");\r\n    } else {\r\n      stream.eatWhile(isOperatorChar);\r\n      return ret(\"operator\", null, stream.current());\r\n    }\r\n  } else if (ch == \"#\") {\r\n    stream.skipToEnd();\r\n    return ret(\"conditional\", \"meta\");\r\n  } else if (ch == \"@\") {\r\n    stream.eat(/:/);\r\n    stream.eatWhile(/[\\w_]/);\r\n    return ret (\"metadata\", \"meta\");\r\n  } else if (isOperatorChar.test(ch)) {\r\n    stream.eatWhile(isOperatorChar);\r\n    return ret(\"operator\", null, stream.current());\r\n  } else {\r\n    var word;\r\n    if(/[A-Z]/.test(ch)) {\r\n      stream.eatWhile(/[\\w_<>]/);\r\n      word = stream.current();\r\n      return ret(\"type\", \"type\", word);\r\n    } else {\r\n      stream.eatWhile(/[\\w_]/);\r\n      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\r\n      return (known && state.kwAllowed) ? ret(known.type, known.style, word) :\r\n        ret(\"variable\", \"variable\", word);\r\n    }\r\n  }\r\n}\r\n\r\nfunction haxeTokenString(quote) {\r\n  return function(stream, state) {\r\n    if (toUnescaped(stream, quote))\r\n      state.tokenize = haxeTokenBase;\r\n    return ret(\"string\", \"string\");\r\n  };\r\n}\r\n\r\nfunction haxeTokenComment(stream, state) {\r\n  var maybeEnd = false, ch;\r\n  while (ch = stream.next()) {\r\n    if (ch == \"/\" && maybeEnd) {\r\n      state.tokenize = haxeTokenBase;\r\n      break;\r\n    }\r\n    maybeEnd = (ch == \"*\");\r\n  }\r\n  return ret(\"comment\", \"comment\");\r\n}\r\n\r\n// Parser\r\n\r\nvar atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true};\r\n\r\nfunction HaxeLexical(indented, column, type, align, prev, info) {\r\n  this.indented = indented;\r\n  this.column = column;\r\n  this.type = type;\r\n  this.prev = prev;\r\n  this.info = info;\r\n  if (align != null) this.align = align;\r\n}\r\n\r\nfunction inScope(state, varname) {\r\n  for (var v = state.localVars; v; v = v.next)\r\n    if (v.name == varname) return true;\r\n}\r\n\r\nfunction parseHaxe(state, style, type, content, stream) {\r\n  var cc = state.cc;\r\n  // Communicate our context to the combinators.\r\n  // (Less wasteful than consing up a hundred closures on every call.)\r\n  cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;\r\n\r\n  if (!state.lexical.hasOwnProperty(\"align\"))\r\n    state.lexical.align = true;\r\n\r\n  while(true) {\r\n    var combinator = cc.length ? cc.pop() : statement;\r\n    if (combinator(type, content)) {\r\n      while(cc.length && cc[cc.length - 1].lex)\r\n        cc.pop()();\r\n      if (cx.marked) return cx.marked;\r\n      if (type == \"variable\" && inScope(state, content)) return \"variableName.local\";\r\n      if (type == \"variable\" && imported(state, content)) return \"variableName.special\";\r\n      return style;\r\n    }\r\n  }\r\n}\r\n\r\nfunction imported(state, typename) {\r\n  if (/[a-z]/.test(typename.charAt(0)))\r\n    return false;\r\n  var len = state.importedtypes.length;\r\n  for (var i = 0; i<len; i++)\r\n    if(state.importedtypes[i]==typename) return true;\r\n}\r\n\r\nfunction registerimport(importname) {\r\n  var state = cx.state;\r\n  for (var t = state.importedtypes; t; t = t.next)\r\n    if(t.name == importname) return;\r\n  state.importedtypes = { name: importname, next: state.importedtypes };\r\n}\r\n// Combinator utils\r\n\r\nvar cx = {state: null, column: null, marked: null, cc: null};\r\nfunction pass() {\r\n  for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\r\n}\r\nfunction cont() {\r\n  pass.apply(null, arguments);\r\n  return true;\r\n}\r\nfunction inList(name, list) {\r\n  for (var v = list; v; v = v.next)\r\n    if (v.name == name) return true;\r\n  return false;\r\n}\r\nfunction register(varname) {\r\n  var state = cx.state;\r\n  if (state.context) {\r\n    cx.marked = \"def\";\r\n    if (inList(varname, state.localVars)) return;\r\n    state.localVars = {name: varname, next: state.localVars};\r\n  } else if (state.globalVars) {\r\n    if (inList(varname, state.globalVars)) return;\r\n    state.globalVars = {name: varname, next: state.globalVars};\r\n  }\r\n}\r\n\r\n// Combinators\r\n\r\nvar defaultVars = {name: \"this\", next: null};\r\nfunction pushcontext() {\r\n  if (!cx.state.context) cx.state.localVars = defaultVars;\r\n  cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\r\n}\r\nfunction popcontext() {\r\n  cx.state.localVars = cx.state.context.vars;\r\n  cx.state.context = cx.state.context.prev;\r\n}\r\npopcontext.lex = true;\r\nfunction pushlex(type, info) {\r\n  var result = function() {\r\n    var state = cx.state;\r\n    state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);\r\n  };\r\n  result.lex = true;\r\n  return result;\r\n}\r\nfunction poplex() {\r\n  var state = cx.state;\r\n  if (state.lexical.prev) {\r\n    if (state.lexical.type == \")\")\r\n      state.indented = state.lexical.indented;\r\n    state.lexical = state.lexical.prev;\r\n  }\r\n}\r\npoplex.lex = true;\r\n\r\nfunction expect(wanted) {\r\n  function f(type) {\r\n    if (type == wanted) return cont();\r\n    else if (wanted == \";\") return pass();\r\n    else return cont(f);\r\n  }\r\n  return f;\r\n}\r\n\r\nfunction statement(type) {\r\n  if (type == \"@\") return cont(metadef);\r\n  if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\r\n  if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\r\n  if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\r\n  if (type == \"{\") return cont(pushlex(\"}\"), pushcontext, block, poplex, popcontext);\r\n  if (type == \";\") return cont();\r\n  if (type == \"attribute\") return cont(maybeattribute);\r\n  if (type == \"function\") return cont(functiondef);\r\n  if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"),\r\n                                 poplex, statement, poplex);\r\n  if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\r\n  if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\r\n                                    block, poplex, poplex);\r\n  if (type == \"case\") return cont(expression, expect(\":\"));\r\n  if (type == \"default\") return cont(expect(\":\"));\r\n  if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\r\n                                   statement, poplex, popcontext);\r\n  if (type == \"import\") return cont(importdef, expect(\";\"));\r\n  if (type == \"typedef\") return cont(typedef);\r\n  return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\r\n}\r\nfunction expression(type) {\r\n  if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\r\n  if (type == \"type\" ) return cont(maybeoperator);\r\n  if (type == \"function\") return cont(functiondef);\r\n  if (type == \"keyword c\") return cont(maybeexpression);\r\n  if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\r\n  if (type == \"operator\") return cont(expression);\r\n  if (type == \"[\") return cont(pushlex(\"]\"), commasep(maybeexpression, \"]\"), poplex, maybeoperator);\r\n  if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\r\n  return cont();\r\n}\r\nfunction maybeexpression(type) {\r\n  if (type.match(/[;\\}\\)\\],]/)) return pass();\r\n  return pass(expression);\r\n}\r\n\r\nfunction maybeoperator(type, value) {\r\n  if (type == \"operator\" && /\\+\\+|--/.test(value)) return cont(maybeoperator);\r\n  if (type == \"operator\" || type == \":\") return cont(expression);\r\n  if (type == \";\") return;\r\n  if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\r\n  if (type == \".\") return cont(property, maybeoperator);\r\n  if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\r\n}\r\n\r\nfunction maybeattribute(type) {\r\n  if (type == \"attribute\") return cont(maybeattribute);\r\n  if (type == \"function\") return cont(functiondef);\r\n  if (type == \"var\") return cont(vardef1);\r\n}\r\n\r\nfunction metadef(type) {\r\n  if(type == \":\") return cont(metadef);\r\n  if(type == \"variable\") return cont(metadef);\r\n  if(type == \"(\") return cont(pushlex(\")\"), commasep(metaargs, \")\"), poplex, statement);\r\n}\r\nfunction metaargs(type) {\r\n  if(type == \"variable\") return cont();\r\n}\r\n\r\nfunction importdef (type, value) {\r\n  if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\r\n  else if(type == \"variable\" || type == \"property\" || type == \".\" || value == \"*\") return cont(importdef);\r\n}\r\n\r\nfunction typedef (type, value)\r\n{\r\n  if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\r\n  else if (type == \"type\" && /[A-Z]/.test(value.charAt(0))) { return cont(); }\r\n}\r\n\r\nfunction maybelabel(type) {\r\n  if (type == \":\") return cont(poplex, statement);\r\n  return pass(maybeoperator, expect(\";\"), poplex);\r\n}\r\nfunction property(type) {\r\n  if (type == \"variable\") {cx.marked = \"property\"; return cont();}\r\n}\r\nfunction objprop(type) {\r\n  if (type == \"variable\") cx.marked = \"property\";\r\n  if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\r\n}\r\nfunction commasep(what, end) {\r\n  function proceed(type) {\r\n    if (type == \",\") return cont(what, proceed);\r\n    if (type == end) return cont();\r\n    return cont(expect(end));\r\n  }\r\n  return function(type) {\r\n    if (type == end) return cont();\r\n    else return pass(what, proceed);\r\n  };\r\n}\r\nfunction block(type) {\r\n  if (type == \"}\") return cont();\r\n  return pass(statement, block);\r\n}\r\nfunction vardef1(type, value) {\r\n  if (type == \"variable\"){register(value); return cont(typeuse, vardef2);}\r\n  return cont();\r\n}\r\nfunction vardef2(type, value) {\r\n  if (value == \"=\") return cont(expression, vardef2);\r\n  if (type == \",\") return cont(vardef1);\r\n}\r\nfunction forspec1(type, value) {\r\n  if (type == \"variable\") {\r\n    register(value);\r\n    return cont(forin, expression)\r\n  } else {\r\n    return pass()\r\n  }\r\n}\r\nfunction forin(_type, value) {\r\n  if (value == \"in\") return cont();\r\n}\r\nfunction functiondef(type, value) {\r\n  //function names starting with upper-case letters are recognised as types, so cludging them together here.\r\n  if (type == \"variable\" || type == \"type\") {register(value); return cont(functiondef);}\r\n  if (value == \"new\") return cont(functiondef);\r\n  if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, typeuse, statement, popcontext);\r\n}\r\nfunction typeuse(type) {\r\n  if(type == \":\") return cont(typestring);\r\n}\r\nfunction typestring(type) {\r\n  if(type == \"type\") return cont();\r\n  if(type == \"variable\") return cont();\r\n  if(type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\"), poplex);\r\n}\r\nfunction typeprop(type) {\r\n  if(type == \"variable\") return cont(typeuse);\r\n}\r\nfunction funarg(type, value) {\r\n  if (type == \"variable\") {register(value); return cont(typeuse);}\r\n}\r\n\r\n// Interface\r\nexport const haxe = {\r\n  name: \"haxe\",\r\n  startState: function(indentUnit) {\r\n    var defaulttypes = [\"Int\", \"Float\", \"String\", \"Void\", \"Std\", \"Bool\", \"Dynamic\", \"Array\"];\r\n    var state = {\r\n      tokenize: haxeTokenBase,\r\n      reAllowed: true,\r\n      kwAllowed: true,\r\n      cc: [],\r\n      lexical: new HaxeLexical(-indentUnit, 0, \"block\", false),\r\n      importedtypes: defaulttypes,\r\n      context: null,\r\n      indented: 0\r\n    };\r\n    return state;\r\n  },\r\n\r\n  token: function(stream, state) {\r\n    if (stream.sol()) {\r\n      if (!state.lexical.hasOwnProperty(\"align\"))\r\n        state.lexical.align = false;\r\n      state.indented = stream.indentation();\r\n    }\r\n    if (stream.eatSpace()) return null;\r\n    var style = state.tokenize(stream, state);\r\n    if (type == \"comment\") return style;\r\n    state.reAllowed = !!(type == \"operator\" || type == \"keyword c\" || type.match(/^[\\[{}\\(,;:]$/));\r\n    state.kwAllowed = type != '.';\r\n    return parseHaxe(state, style, type, content, stream);\r\n  },\r\n\r\n  indent: function(state, textAfter, cx) {\r\n    if (state.tokenize != haxeTokenBase) return 0;\r\n    var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\r\n    if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\r\n    var type = lexical.type, closing = firstChar == type;\r\n    if (type == \"vardef\") return lexical.indented + 4;\r\n    else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\r\n    else if (type == \"stat\" || type == \"form\") return lexical.indented + cx.unit;\r\n    else if (lexical.info == \"switch\" && !closing)\r\n      return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? cx.unit : 2 * cx.unit);\r\n    else if (lexical.align) return lexical.column + (closing ? 0 : 1);\r\n    else return lexical.indented + (closing ? 0 : cx.unit);\r\n  },\r\n\r\n  languageData: {\r\n    indentOnInput: /^\\s*[{}]$/,\r\n    commentTokens: {line: \"//\", block: {open: \"/*\", close: \"*/\"}}\r\n  }\r\n};\r\n\r\nexport const hxml = {\r\n  name: \"hxml\",\r\n  startState: function () {\r\n    return {\r\n      define: false,\r\n      inString: false\r\n    };\r\n  },\r\n  token: function (stream, state) {\r\n    var ch = stream.peek();\r\n    var sol = stream.sol();\r\n\r\n    ///* comments */\r\n    if (ch == \"#\") {\r\n      stream.skipToEnd();\r\n      return \"comment\";\r\n    }\r\n    if (sol && ch == \"-\") {\r\n      var style = \"variable-2\";\r\n\r\n      stream.eat(/-/);\r\n\r\n      if (stream.peek() == \"-\") {\r\n        stream.eat(/-/);\r\n        style = \"keyword a\";\r\n      }\r\n\r\n      if (stream.peek() == \"D\") {\r\n        stream.eat(/[D]/);\r\n        style = \"keyword c\";\r\n        state.define = true;\r\n      }\r\n\r\n      stream.eatWhile(/[A-Z]/i);\r\n      return style;\r\n    }\r\n\r\n    var ch = stream.peek();\r\n\r\n    if (state.inString == false && ch == \"'\") {\r\n      state.inString = true;\r\n      stream.next();\r\n    }\r\n\r\n    if (state.inString == true) {\r\n      if (stream.skipTo(\"'\")) {\r\n\r\n      } else {\r\n        stream.skipToEnd();\r\n      }\r\n\r\n      if (stream.peek() == \"'\") {\r\n        stream.next();\r\n        state.inString = false;\r\n      }\r\n\r\n      return \"string\";\r\n    }\r\n\r\n    stream.next();\r\n    return null;\r\n  },\r\n  languageData: {\r\n    commentTokens: {line: \"#\"}\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": ["type", "cont", "content", "cx"]
}
