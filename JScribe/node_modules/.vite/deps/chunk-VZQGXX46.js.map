{
  "version": 3,
  "sources": ["../../@codemirror/legacy-modes/mode/mbox.js"],
  "sourcesContent": ["var rfc2822 = [\r\n  \"From\", \"Sender\", \"Reply-To\", \"To\", \"Cc\", \"Bcc\", \"Message-ID\",\r\n  \"In-Reply-To\", \"References\", \"Resent-From\", \"Resent-Sender\", \"Resent-To\",\r\n  \"Resent-Cc\", \"Resent-Bcc\", \"Resent-Message-ID\", \"Return-Path\", \"Received\"\r\n];\r\nvar rfc2822NoEmail = [\r\n  \"Date\", \"Subject\", \"Comments\", \"Keywords\", \"Resent-Date\"\r\n];\r\n\r\nvar whitespace = /^[ \\t]/;\r\nvar separator = /^From /; // See RFC 4155\r\nvar rfc2822Header = new RegExp(\"^(\" + rfc2822.join(\"|\") + \"): \");\r\nvar rfc2822HeaderNoEmail = new RegExp(\"^(\" + rfc2822NoEmail.join(\"|\") + \"): \");\r\nvar header = /^[^:]+:/; // Optional fields defined in RFC 2822\r\nvar email = /^[^ ]+@[^ ]+/;\r\nvar untilEmail = /^.*?(?=[^ ]+?@[^ ]+)/;\r\nvar bracketedEmail = /^<.*?>/;\r\nvar untilBracketedEmail = /^.*?(?=<.*>)/;\r\n\r\nfunction styleForHeader(header) {\r\n  if (header === \"Subject\") return \"header\";\r\n  return \"string\";\r\n}\r\n\r\nfunction readToken(stream, state) {\r\n  if (stream.sol()) {\r\n    // From last line\r\n    state.inSeparator = false;\r\n    if (state.inHeader && stream.match(whitespace)) {\r\n      // Header folding\r\n      return null;\r\n    } else {\r\n      state.inHeader = false;\r\n      state.header = null;\r\n    }\r\n\r\n    if (stream.match(separator)) {\r\n      state.inHeaders = true;\r\n      state.inSeparator = true;\r\n      return \"atom\";\r\n    }\r\n\r\n    var match;\r\n    var emailPermitted = false;\r\n    if ((match = stream.match(rfc2822HeaderNoEmail)) ||\r\n        (emailPermitted = true) && (match = stream.match(rfc2822Header))) {\r\n      state.inHeaders = true;\r\n      state.inHeader = true;\r\n      state.emailPermitted = emailPermitted;\r\n      state.header = match[1];\r\n      return \"atom\";\r\n    }\r\n\r\n    // Use vim's heuristics: recognize custom headers only if the line is in a\r\n    // block of legitimate headers.\r\n    if (state.inHeaders && (match = stream.match(header))) {\r\n      state.inHeader = true;\r\n      state.emailPermitted = true;\r\n      state.header = match[1];\r\n      return \"atom\";\r\n    }\r\n\r\n    state.inHeaders = false;\r\n    stream.skipToEnd();\r\n    return null;\r\n  }\r\n\r\n  if (state.inSeparator) {\r\n    if (stream.match(email)) return \"link\";\r\n    if (stream.match(untilEmail)) return \"atom\";\r\n    stream.skipToEnd();\r\n    return \"atom\";\r\n  }\r\n\r\n  if (state.inHeader) {\r\n    var style = styleForHeader(state.header);\r\n\r\n    if (state.emailPermitted) {\r\n      if (stream.match(bracketedEmail)) return style + \" link\";\r\n      if (stream.match(untilBracketedEmail)) return style;\r\n    }\r\n    stream.skipToEnd();\r\n    return style;\r\n  }\r\n\r\n  stream.skipToEnd();\r\n  return null;\r\n};\r\n\r\nexport const mbox = {\r\n  name: \"mbox\",\r\n  startState: function() {\r\n    return {\r\n      // Is in a mbox separator\r\n      inSeparator: false,\r\n      // Is in a mail header\r\n      inHeader: false,\r\n      // If bracketed email is permitted. Only applicable when inHeader\r\n      emailPermitted: false,\r\n      // Name of current header\r\n      header: null,\r\n      // Is in a region of mail headers\r\n      inHeaders: false\r\n    };\r\n  },\r\n  token: readToken,\r\n  blankLine: function(state) {\r\n    state.inHeaders = state.inSeparator = state.inHeader = false;\r\n  },\r\n  languageData: {\r\n    autocomplete: rfc2822.concat(rfc2822NoEmail)\r\n  }\r\n}\r\n\r\n"],
  "mappings": ";AAAA,IAAI,UAAU;AAAA,EACZ;AAAA,EAAQ;AAAA,EAAU;AAAA,EAAY;AAAA,EAAM;AAAA,EAAM;AAAA,EAAO;AAAA,EACjD;AAAA,EAAe;AAAA,EAAc;AAAA,EAAe;AAAA,EAAiB;AAAA,EAC7D;AAAA,EAAa;AAAA,EAAc;AAAA,EAAqB;AAAA,EAAe;AACjE;AACA,IAAI,iBAAiB;AAAA,EACnB;AAAA,EAAQ;AAAA,EAAW;AAAA,EAAY;AAAA,EAAY;AAC7C;AAEA,IAAI,aAAa;AACjB,IAAI,YAAY;AAChB,IAAI,gBAAgB,IAAI,OAAO,OAAO,QAAQ,KAAK,GAAG,IAAI,KAAK;AAC/D,IAAI,uBAAuB,IAAI,OAAO,OAAO,eAAe,KAAK,GAAG,IAAI,KAAK;AAC7E,IAAI,SAAS;AACb,IAAI,QAAQ;AACZ,IAAI,aAAa;AACjB,IAAI,iBAAiB;AACrB,IAAI,sBAAsB;AAE1B,SAAS,eAAeA,SAAQ;AAC9B,MAAIA,YAAW,UAAW,QAAO;AACjC,SAAO;AACT;AAEA,SAAS,UAAU,QAAQ,OAAO;AAChC,MAAI,OAAO,IAAI,GAAG;AAEhB,UAAM,cAAc;AACpB,QAAI,MAAM,YAAY,OAAO,MAAM,UAAU,GAAG;AAE9C,aAAO;AAAA,IACT,OAAO;AACL,YAAM,WAAW;AACjB,YAAM,SAAS;AAAA,IACjB;AAEA,QAAI,OAAO,MAAM,SAAS,GAAG;AAC3B,YAAM,YAAY;AAClB,YAAM,cAAc;AACpB,aAAO;AAAA,IACT;AAEA,QAAI;AACJ,QAAI,iBAAiB;AACrB,SAAK,QAAQ,OAAO,MAAM,oBAAoB,OACzC,iBAAiB,UAAU,QAAQ,OAAO,MAAM,aAAa,IAAI;AACpE,YAAM,YAAY;AAClB,YAAM,WAAW;AACjB,YAAM,iBAAiB;AACvB,YAAM,SAAS,MAAM,CAAC;AACtB,aAAO;AAAA,IACT;AAIA,QAAI,MAAM,cAAc,QAAQ,OAAO,MAAM,MAAM,IAAI;AACrD,YAAM,WAAW;AACjB,YAAM,iBAAiB;AACvB,YAAM,SAAS,MAAM,CAAC;AACtB,aAAO;AAAA,IACT;AAEA,UAAM,YAAY;AAClB,WAAO,UAAU;AACjB,WAAO;AAAA,EACT;AAEA,MAAI,MAAM,aAAa;AACrB,QAAI,OAAO,MAAM,KAAK,EAAG,QAAO;AAChC,QAAI,OAAO,MAAM,UAAU,EAAG,QAAO;AACrC,WAAO,UAAU;AACjB,WAAO;AAAA,EACT;AAEA,MAAI,MAAM,UAAU;AAClB,QAAI,QAAQ,eAAe,MAAM,MAAM;AAEvC,QAAI,MAAM,gBAAgB;AACxB,UAAI,OAAO,MAAM,cAAc,EAAG,QAAO,QAAQ;AACjD,UAAI,OAAO,MAAM,mBAAmB,EAAG,QAAO;AAAA,IAChD;AACA,WAAO,UAAU;AACjB,WAAO;AAAA,EACT;AAEA,SAAO,UAAU;AACjB,SAAO;AACT;AAEO,IAAM,OAAO;AAAA,EAClB,MAAM;AAAA,EACN,YAAY,WAAW;AACrB,WAAO;AAAA;AAAA,MAEL,aAAa;AAAA;AAAA,MAEb,UAAU;AAAA;AAAA,MAEV,gBAAgB;AAAA;AAAA,MAEhB,QAAQ;AAAA;AAAA,MAER,WAAW;AAAA,IACb;AAAA,EACF;AAAA,EACA,OAAO;AAAA,EACP,WAAW,SAAS,OAAO;AACzB,UAAM,YAAY,MAAM,cAAc,MAAM,WAAW;AAAA,EACzD;AAAA,EACA,cAAc;AAAA,IACZ,cAAc,QAAQ,OAAO,cAAc;AAAA,EAC7C;AACF;",
  "names": ["header"]
}
