{
  "version": 3,
  "sources": ["../../@codemirror/legacy-modes/mode/pascal.js"],
  "sourcesContent": ["function words(str) {\r\n  var obj = {}, words = str.split(\" \");\r\n  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\r\n  return obj;\r\n}\r\nvar keywords = words(\r\n  \"absolute and array asm begin case const constructor destructor div do \" +\r\n    \"downto else end file for function goto if implementation in inherited \" +\r\n    \"inline interface label mod nil not object of operator or packed procedure \" +\r\n    \"program record reintroduce repeat self set shl shr string then to type \" +\r\n    \"unit until uses var while with xor as class dispinterface except exports \" +\r\n    \"finalization finally initialization inline is library on out packed \" +\r\n    \"property raise resourcestring threadvar try absolute abstract alias \" +\r\n    \"assembler bitpacked break cdecl continue cppdecl cvar default deprecated \" +\r\n    \"dynamic enumerator experimental export external far far16 forward generic \" +\r\n    \"helper implements index interrupt iocheck local message name near \" +\r\n    \"nodefault noreturn nostackframe oldfpccall otherwise overload override \" +\r\n    \"pascal platform private protected public published read register \" +\r\n    \"reintroduce result safecall saveregisters softfloat specialize static \" +\r\n    \"stdcall stored strict unaligned unimplemented varargs virtual write\");\r\nvar atoms = {\"null\": true};\r\n\r\nvar isOperatorChar = /[+\\-*&%=<>!?|\\/]/;\r\n\r\nfunction tokenBase(stream, state) {\r\n  var ch = stream.next();\r\n  if (ch == \"#\" && state.startOfLine) {\r\n    stream.skipToEnd();\r\n    return \"meta\";\r\n  }\r\n  if (ch == '\"' || ch == \"'\") {\r\n    state.tokenize = tokenString(ch);\r\n    return state.tokenize(stream, state);\r\n  }\r\n  if (ch == \"(\" && stream.eat(\"*\")) {\r\n    state.tokenize = tokenComment;\r\n    return tokenComment(stream, state);\r\n  }\r\n  if (ch == \"{\") {\r\n    state.tokenize = tokenCommentBraces;\r\n    return tokenCommentBraces(stream, state);\r\n  }\r\n  if (/[\\[\\]\\(\\),;\\:\\.]/.test(ch)) {\r\n    return null;\r\n  }\r\n  if (/\\d/.test(ch)) {\r\n    stream.eatWhile(/[\\w\\.]/);\r\n    return \"number\";\r\n  }\r\n  if (ch == \"/\") {\r\n    if (stream.eat(\"/\")) {\r\n      stream.skipToEnd();\r\n      return \"comment\";\r\n    }\r\n  }\r\n  if (isOperatorChar.test(ch)) {\r\n    stream.eatWhile(isOperatorChar);\r\n    return \"operator\";\r\n  }\r\n  stream.eatWhile(/[\\w\\$_]/);\r\n  var cur = stream.current();\r\n  if (keywords.propertyIsEnumerable(cur)) return \"keyword\";\r\n  if (atoms.propertyIsEnumerable(cur)) return \"atom\";\r\n  return \"variable\";\r\n}\r\n\r\nfunction tokenString(quote) {\r\n  return function(stream, state) {\r\n    var escaped = false, next, end = false;\r\n    while ((next = stream.next()) != null) {\r\n      if (next == quote && !escaped) {end = true; break;}\r\n      escaped = !escaped && next == \"\\\\\";\r\n    }\r\n    if (end || !escaped) state.tokenize = null;\r\n    return \"string\";\r\n  };\r\n}\r\n\r\nfunction tokenComment(stream, state) {\r\n  var maybeEnd = false, ch;\r\n  while (ch = stream.next()) {\r\n    if (ch == \")\" && maybeEnd) {\r\n      state.tokenize = null;\r\n      break;\r\n    }\r\n    maybeEnd = (ch == \"*\");\r\n  }\r\n  return \"comment\";\r\n}\r\n\r\nfunction tokenCommentBraces(stream, state) {\r\n  var ch;\r\n  while (ch = stream.next()) {\r\n    if (ch == \"}\") {\r\n      state.tokenize = null;\r\n      break;\r\n    }\r\n  }\r\n  return \"comment\";\r\n}\r\n\r\n// Interface\r\n\r\nexport const pascal = {\r\n  name: \"pascal\",\r\n\r\n  startState: function() {\r\n    return {tokenize: null};\r\n  },\r\n\r\n  token: function(stream, state) {\r\n    if (stream.eatSpace()) return null;\r\n    var style = (state.tokenize || tokenBase)(stream, state);\r\n    if (style == \"comment\" || style == \"meta\") return style;\r\n    return style;\r\n  },\r\n\r\n  languageData: {\r\n    indentOnInput: /^\\s*[{}]$/,\r\n    commentTokens: {block: {open: \"(*\", close: \"*)\"}}\r\n  }\r\n};\r\n"],
  "mappings": ";AAAA,SAAS,MAAM,KAAK;AAClB,MAAI,MAAM,CAAC,GAAGA,SAAQ,IAAI,MAAM,GAAG;AACnC,WAAS,IAAI,GAAG,IAAIA,OAAM,QAAQ,EAAE,EAAG,KAAIA,OAAM,CAAC,CAAC,IAAI;AACvD,SAAO;AACT;AACA,IAAI,WAAW;AAAA,EACb;AAauE;AACzE,IAAI,QAAQ,EAAC,QAAQ,KAAI;AAEzB,IAAI,iBAAiB;AAErB,SAAS,UAAU,QAAQ,OAAO;AAChC,MAAI,KAAK,OAAO,KAAK;AACrB,MAAI,MAAM,OAAO,MAAM,aAAa;AAClC,WAAO,UAAU;AACjB,WAAO;AAAA,EACT;AACA,MAAI,MAAM,OAAO,MAAM,KAAK;AAC1B,UAAM,WAAW,YAAY,EAAE;AAC/B,WAAO,MAAM,SAAS,QAAQ,KAAK;AAAA,EACrC;AACA,MAAI,MAAM,OAAO,OAAO,IAAI,GAAG,GAAG;AAChC,UAAM,WAAW;AACjB,WAAO,aAAa,QAAQ,KAAK;AAAA,EACnC;AACA,MAAI,MAAM,KAAK;AACb,UAAM,WAAW;AACjB,WAAO,mBAAmB,QAAQ,KAAK;AAAA,EACzC;AACA,MAAI,mBAAmB,KAAK,EAAE,GAAG;AAC/B,WAAO;AAAA,EACT;AACA,MAAI,KAAK,KAAK,EAAE,GAAG;AACjB,WAAO,SAAS,QAAQ;AACxB,WAAO;AAAA,EACT;AACA,MAAI,MAAM,KAAK;AACb,QAAI,OAAO,IAAI,GAAG,GAAG;AACnB,aAAO,UAAU;AACjB,aAAO;AAAA,IACT;AAAA,EACF;AACA,MAAI,eAAe,KAAK,EAAE,GAAG;AAC3B,WAAO,SAAS,cAAc;AAC9B,WAAO;AAAA,EACT;AACA,SAAO,SAAS,SAAS;AACzB,MAAI,MAAM,OAAO,QAAQ;AACzB,MAAI,SAAS,qBAAqB,GAAG,EAAG,QAAO;AAC/C,MAAI,MAAM,qBAAqB,GAAG,EAAG,QAAO;AAC5C,SAAO;AACT;AAEA,SAAS,YAAY,OAAO;AAC1B,SAAO,SAAS,QAAQ,OAAO;AAC7B,QAAI,UAAU,OAAO,MAAM,MAAM;AACjC,YAAQ,OAAO,OAAO,KAAK,MAAM,MAAM;AACrC,UAAI,QAAQ,SAAS,CAAC,SAAS;AAAC,cAAM;AAAM;AAAA,MAAM;AAClD,gBAAU,CAAC,WAAW,QAAQ;AAAA,IAChC;AACA,QAAI,OAAO,CAAC,QAAS,OAAM,WAAW;AACtC,WAAO;AAAA,EACT;AACF;AAEA,SAAS,aAAa,QAAQ,OAAO;AACnC,MAAI,WAAW,OAAO;AACtB,SAAO,KAAK,OAAO,KAAK,GAAG;AACzB,QAAI,MAAM,OAAO,UAAU;AACzB,YAAM,WAAW;AACjB;AAAA,IACF;AACA,eAAY,MAAM;AAAA,EACpB;AACA,SAAO;AACT;AAEA,SAAS,mBAAmB,QAAQ,OAAO;AACzC,MAAI;AACJ,SAAO,KAAK,OAAO,KAAK,GAAG;AACzB,QAAI,MAAM,KAAK;AACb,YAAM,WAAW;AACjB;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAIO,IAAM,SAAS;AAAA,EACpB,MAAM;AAAA,EAEN,YAAY,WAAW;AACrB,WAAO,EAAC,UAAU,KAAI;AAAA,EACxB;AAAA,EAEA,OAAO,SAAS,QAAQ,OAAO;AAC7B,QAAI,OAAO,SAAS,EAAG,QAAO;AAC9B,QAAI,SAAS,MAAM,YAAY,WAAW,QAAQ,KAAK;AACvD,QAAI,SAAS,aAAa,SAAS,OAAQ,QAAO;AAClD,WAAO;AAAA,EACT;AAAA,EAEA,cAAc;AAAA,IACZ,eAAe;AAAA,IACf,eAAe,EAAC,OAAO,EAAC,MAAM,MAAM,OAAO,KAAI,EAAC;AAAA,EAClD;AACF;",
  "names": ["words"]
}
